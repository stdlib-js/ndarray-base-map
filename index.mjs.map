{"version":3,"file":"index.mjs","sources":["../lib/nd_accessors.js","../lib/nd.js","../lib/main.js","../lib/0d.js","../lib/1d.js","../lib/2d.js","../lib/3d.js","../lib/4d.js","../lib/5d.js","../lib/6d.js","../lib/7d.js","../lib/8d.js","../lib/9d.js","../lib/10d.js","../lib/0d_accessors.js","../lib/1d_accessors.js","../lib/2d_accessors.js","../lib/3d_accessors.js","../lib/4d_accessors.js","../lib/5d_accessors.js","../lib/6d_accessors.js","../lib/7d_accessors.js","../lib/8d_accessors.js","../lib/9d_accessors.js","../lib/10d_accessors.js","../lib/2d_blocked.js","../lib/3d_blocked.js","../lib/4d_blocked.js","../lib/5d_blocked.js","../lib/6d_blocked.js","../lib/7d_blocked.js","../lib/8d_blocked.js","../lib/9d_blocked.js","../lib/10d_blocked.js","../lib/2d_blocked_accessors.js","../lib/3d_blocked_accessors.js","../lib/4d_blocked_accessors.js","../lib/5d_blocked_accessors.js","../lib/6d_blocked_accessors.js","../lib/7d_blocked_accessors.js","../lib/8d_blocked_accessors.js","../lib/9d_blocked_accessors.js","../lib/10d_blocked_accessors.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport numel from '@stdlib/ndarray-base-numel';\nimport vind2bind from '@stdlib/ndarray-base-vind2bind';\nimport ind2sub from '@stdlib/ndarray-base-ind2sub';\n\n\n// VARIABLES //\n\nvar MODE = 'throw';\n\n\n// MAIN //\n\n/**\n* Applies a callback function to elements in an -dimensional input ndarray and assigns results to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {string} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback execution context\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import Complex64 from '@stdlib/complex-float32-ctor';\n* import realf from '@stdlib/complex-float32-real';\n* import imagf from '@stdlib/complex-float32-imag';\n*\n* function scale( z ) {\n*     return new Complex64( realf(z)*10.0, imagf(z)*10.0 );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Complex64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 2, 1 ];\n* var sy = [ 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'ref': null,\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n* var y = {\n*     'dtype': 'complex64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Apply the map function:\n* mapnd( x, y, scale, {} );\n*\n* var v = y.data.get( 0 );\n*\n* var re = realf( v );\n* // returns 10.0\n*\n* var im = imagf( v );\n* // returns 20.0\n*/\nfunction mapnd( x, y, fcn, thisArg ) {\n\tvar xbuf;\n\tvar ybuf;\n\tvar ordx;\n\tvar ordy;\n\tvar len;\n\tvar get;\n\tvar set;\n\tvar idx;\n\tvar sh;\n\tvar sx;\n\tvar sy;\n\tvar ox;\n\tvar oy;\n\tvar ix;\n\tvar iy;\n\tvar i;\n\n\tsh = x.shape;\n\n\t// Compute the total number of elements over which to iterate:\n\tlen = numel( sh );\n\n\t// Cache references to the input and output ndarray data buffers:\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache references to the respective stride arrays:\n\tsx = x.strides;\n\tsy = y.strides;\n\n\t// Cache the indices of the first indexed elements in the respective ndarrays:\n\tox = x.offset;\n\toy = y.offset;\n\n\t// Cache the respective array orders:\n\tordx = x.order;\n\tordy = y.order;\n\n\t// Cache accessors:\n\tget = x.accessors[ 0 ];\n\tset = y.accessors[ 1 ];\n\n\t// Iterate over each element based on the linear **view** index, regardless as to how the data is stored in memory...\n\tfor ( i = 0; i < len; i++ ) {\n\t\tix = vind2bind( sh, sx, ox, ordx, i, MODE );\n\t\tiy = vind2bind( sh, sy, oy, ordy, i, MODE );\n\t\tidx = ind2sub( sh, sx, 0, ordx, i, MODE ); // return subscripts from the perspective of the ndarray view\n\t\tset( ybuf, iy, fcn.call( thisArg, get( xbuf, ix ), idx, x.ref ) );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default mapnd;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport numel from '@stdlib/ndarray-base-numel';\nimport vind2bind from '@stdlib/ndarray-base-vind2bind';\nimport ind2sub from '@stdlib/ndarray-base-ind2sub';\n\n\n// VARIABLES //\n\nvar MODE = 'throw';\n\n\n// MAIN //\n\n/**\n* Applies a callback function to elements in an n-dimensional input ndarray and assigns results to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {string} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback execution context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* function scale( x ) {\n*     return x * 10.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Float64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 1 ];\n* var sy = [ 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 1;\n* var oy = 0;\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Apply the map function:\n* mapnd( x, y, scale, {} );\n*\n* console.log( y.data );\n* // => <Float64Array>[ 20.0, 30.0, 60.0, 70.0 ]\n*/\nfunction mapnd( x, y, fcn, thisArg ) {\n\tvar xbuf;\n\tvar ybuf;\n\tvar ordx;\n\tvar ordy;\n\tvar len;\n\tvar idx;\n\tvar sh;\n\tvar sx;\n\tvar sy;\n\tvar ox;\n\tvar oy;\n\tvar ix;\n\tvar iy;\n\tvar i;\n\n\tsh = x.shape;\n\n\t// Compute the total number of elements over which to iterate:\n\tlen = numel( sh );\n\n\t// Cache references to the input and output ndarray data buffers:\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache references to the respective stride arrays:\n\tsx = x.strides;\n\tsy = y.strides;\n\n\t// Cache the indices of the first indexed elements in the respective ndarrays:\n\tox = x.offset;\n\toy = y.offset;\n\n\t// Cache the respective array orders:\n\tordx = x.order;\n\tordy = y.order;\n\n\t// Iterate over each element based on the linear **view** index, regardless as to how the data is stored in memory...\n\tfor ( i = 0; i < len; i++ ) {\n\t\tix = vind2bind( sh, sx, ox, ordx, i, MODE );\n\t\tiy = vind2bind( sh, sy, oy, ordy, i, MODE );\n\t\tidx = ind2sub( sh, sx, 0, ordx, i, MODE ); // return subscripts from the perspective of the ndarray view\n\t\tybuf[ iy ] = fcn.call( thisArg, xbuf[ ix ], idx, x.ref );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default mapnd;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport iterationOrder from '@stdlib/ndarray-base-iteration-order';\nimport minmaxViewBufferIndex from '@stdlib/ndarray-base-minmax-view-buffer-index';\nimport ndarray2object from '@stdlib/ndarray-base-ndarraylike2object';\nimport blockedaccessormap2d from './2d_blocked_accessors.js';\nimport blockedaccessormap3d from './3d_blocked_accessors.js';\nimport blockedaccessormap4d from './4d_blocked_accessors.js';\nimport blockedaccessormap5d from './5d_blocked_accessors.js';\nimport blockedaccessormap6d from './6d_blocked_accessors.js';\nimport blockedaccessormap7d from './7d_blocked_accessors.js';\nimport blockedaccessormap8d from './8d_blocked_accessors.js';\nimport blockedaccessormap9d from './9d_blocked_accessors.js';\nimport blockedaccessormap10d from './10d_blocked_accessors.js';\nimport blockedmap2d from './2d_blocked.js';\nimport blockedmap3d from './3d_blocked.js';\nimport blockedmap4d from './4d_blocked.js';\nimport blockedmap5d from './5d_blocked.js';\nimport blockedmap6d from './6d_blocked.js';\nimport blockedmap7d from './7d_blocked.js';\nimport blockedmap8d from './8d_blocked.js';\nimport blockedmap9d from './9d_blocked.js';\nimport blockedmap10d from './10d_blocked.js';\nimport accessormap0d from './0d_accessors.js';\nimport accessormap1d from './1d_accessors.js';\nimport accessormap2d from './2d_accessors.js';\nimport accessormap3d from './3d_accessors.js';\nimport accessormap4d from './4d_accessors.js';\nimport accessormap5d from './5d_accessors.js';\nimport accessormap6d from './6d_accessors.js';\nimport accessormap7d from './7d_accessors.js';\nimport accessormap8d from './8d_accessors.js';\nimport accessormap9d from './9d_accessors.js';\nimport accessormap10d from './10d_accessors.js';\nimport accessormapnd from './nd_accessors.js';\nimport map0d from './0d.js';\nimport map1d from './1d.js';\nimport map2d from './2d.js';\nimport map3d from './3d.js';\nimport map4d from './4d.js';\nimport map5d from './5d.js';\nimport map6d from './6d.js';\nimport map7d from './7d.js';\nimport map8d from './8d.js';\nimport map9d from './9d.js';\nimport map10d from './10d.js';\nimport mapnd from './nd.js';\n\n\n// VARIABLES //\n\nvar MAP = [\n\tmap0d,\n\tmap1d,\n\tmap2d,\n\tmap3d,\n\tmap4d,\n\tmap5d,\n\tmap6d,\n\tmap7d,\n\tmap8d,\n\tmap9d,\n\tmap10d\n];\nvar ACCESSOR_MAP = [\n\taccessormap0d,\n\taccessormap1d,\n\taccessormap2d,\n\taccessormap3d,\n\taccessormap4d,\n\taccessormap5d,\n\taccessormap6d,\n\taccessormap7d,\n\taccessormap8d,\n\taccessormap9d,\n\taccessormap10d\n];\nvar BLOCKED_MAP = [\n\tblockedmap2d, // 0\n\tblockedmap3d,\n\tblockedmap4d,\n\tblockedmap5d,\n\tblockedmap6d,\n\tblockedmap7d,\n\tblockedmap8d,\n\tblockedmap9d,\n\tblockedmap10d // 8\n];\nvar BLOCKED_ACCESSOR_MAP = [\n\tblockedaccessormap2d, // 0\n\tblockedaccessormap3d,\n\tblockedaccessormap4d,\n\tblockedaccessormap5d,\n\tblockedaccessormap6d,\n\tblockedaccessormap7d,\n\tblockedaccessormap8d,\n\tblockedaccessormap9d,\n\tblockedaccessormap10d // 8\n];\nvar MAX_DIMS = MAP.length -1;\n\n\n// MAIN //\n\n/**\n* Applies a callback function to the elements in an input ndarray and assigns results to the elements in an output ndarray.\n*\n* ## Notes\n*\n* -   Each provided ndarray should be an `object` with the following properties:\n*\n*     -   **dtype**: data type.\n*     -   **data**: data buffer.\n*     -   **shape**: dimensions.\n*     -   **strides**: stride lengths.\n*     -   **offset**: index offset.\n*     -   **order**: specifies whether an ndarray is row-major (C-style) or column major (Fortran-style).\n*\n* @param {ArrayLikeObject<Object>} arrays - array-like object containing one input array and one output array\n* @param {Callback} fcn - callback function\n* @param {*} [thisArg] - callback execution context\n* @throws {Error} arrays must have the same number of dimensions\n* @throws {Error} arrays must have the same shape\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* function scale( z ) {\n*     return z * 10.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( 6 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 1 ];\n* var sy = [ 2, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 1;\n* var oy = 0;\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Apply the map function:\n* map( [ x, y ], scale );\n*\n* console.log( y.data );\n* // => <Float64Array>[ 20.0, 30.0, 60.0, 70.0, 100.0, 110.0 ]\n*/\nfunction map( arrays, fcn, thisArg ) {\n\tvar ndims;\n\tvar xmmv;\n\tvar ymmv;\n\tvar shx;\n\tvar shy;\n\tvar iox;\n\tvar ioy;\n\tvar len;\n\tvar sx;\n\tvar sy;\n\tvar ox;\n\tvar oy;\n\tvar ns;\n\tvar x;\n\tvar y;\n\tvar i;\n\tvar d;\n\n\t// Unpack the ndarrays and standardize ndarray meta data:\n\tx = ndarray2object( arrays[ 0 ] );\n\ty = ndarray2object( arrays[ 1 ] );\n\n\t// Verify that the input and output arrays have the same number of dimensions...\n\tshx = x.shape;\n\tshy = y.shape;\n\tndims = shx.length;\n\tif ( ndims !== shy.length ) {\n\t\tthrow new Error( 'invalid arguments. Arrays must have the same number of dimensions (i.e., same rank). ndims(x) == '+ndims+'. ndims(y) == '+shy.length+'.' );\n\t}\n\t// Determine whether we can avoid iteration altogether...\n\tif ( ndims === 0 ) {\n\t\tif ( x.accessorProtocol || y.accessorProtocol ) {\n\t\t\treturn ACCESSOR_MAP[ ndims ]( x, y, fcn, thisArg );\n\t\t}\n\t\treturn MAP[ ndims ]( x, y, fcn, thisArg );\n\t}\n\t// Verify that the input and output arrays have the same dimensions...\n\tlen = 1; // number of elements\n\tns = 0; // number of singleton dimensions\n\tfor ( i = 0; i < ndims; i++ ) {\n\t\td = shx[ i ];\n\t\tif ( d !== shy[ i ] ) {\n\t\t\tthrow new Error( 'invalid arguments. Array must have the same shape.' );\n\t\t}\n\t\t// Note that, if one of the dimensions is `0`, the length will be `0`...\n\t\tlen *= d;\n\n\t\t// Check whether the current dimension is a singleton dimension...\n\t\tif ( d === 1 ) {\n\t\t\tns += 1;\n\t\t}\n\t}\n\t// Check whether we were provided empty ndarrays...\n\tif ( len === 0 ) {\n\t\treturn;\n\t}\n\t// Determine whether the ndarrays are one-dimensional and thus readily translate to one-dimensional strided arrays...\n\tif ( ndims === 1 ) {\n\t\tif ( x.accessorProtocol || y.accessorProtocol ) {\n\t\t\treturn ACCESSOR_MAP[ ndims ]( x, y, fcn, thisArg );\n\t\t}\n\t\treturn MAP[ ndims ]( x, y, fcn, thisArg );\n\t}\n\n\tsx = x.strides;\n\tsy = y.strides;\n\n\t// Determine whether the ndarray has only **one** non-singleton dimension (e.g., ndims=4, shape=[10,1,1,1]) so that we can treat the ndarrays as being equivalent to one-dimensional strided arrays...\n\tif ( ns === ndims-1 ) {\n\t\t// Get the index of the non-singleton dimension...\n\t\tfor ( i = 0; i < ndims; i++ ) {\n\t\t\tif ( shx[ i ] !== 1 ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tx.shape = [ shx[i] ];\n\t\ty.shape = x.shape;\n\t\tx.strides = [ sx[i] ];\n\t\ty.strides = [ sy[i] ];\n\t\tif ( x.accessorProtocol || y.accessorProtocol ) {\n\t\t\treturn ACCESSOR_MAP[ 1 ]( x, y, fcn, thisArg );\n\t\t}\n\t\treturn MAP[ 1 ]( x, y, fcn, thisArg );\n\t}\n\n\tiox = iterationOrder( sx ); // +/-1\n\tioy = iterationOrder( sy ); // +/-1\n\n\t// Determine whether we can avoid blocked iteration...\n\tif ( iox !== 0 && ioy !== 0 && iox === ioy ) {\n\t\t// Determine the minimum and maximum linear indices which are accessible by the array views:\n\t\txmmv = minmaxViewBufferIndex( shx, sx, x.offset );\n\t\tymmv = minmaxViewBufferIndex( shy, sy, y.offset );\n\n\t\t// Determine whether we can ignore shape (and strides) and treat the ndarrays as linear one-dimensional strided arrays...\n\t\tif ( len === ( xmmv[1]-xmmv[0]+1 ) && len === ( ymmv[1]-ymmv[0]+1 ) ) {\n\t\t\t// Note: the above is equivalent to @stdlib/ndarray/base/assert/is-contiguous, but in-lined so we can retain computed values...\n\t\t\tif ( iox === 1 ) {\n\t\t\t\tox = xmmv[ 0 ];\n\t\t\t} else {\n\t\t\t\tox = xmmv[ 1 ];\n\t\t\t}\n\t\t\tif ( ioy === 1 ) {\n\t\t\t\toy = ymmv[ 0 ];\n\t\t\t} else {\n\t\t\t\toy = ymmv[ 1 ];\n\t\t\t}\n\t\t\tx.shape = [ len ];\n\t\t\ty.shape = x.shape;\n\t\t\tx.strides = [ iox ];\n\t\t\ty.strides = [ ioy ];\n\t\t\tx.offset = ox;\n\t\t\ty.offset = oy;\n\t\t\tif ( x.accessorProtocol || y.accessorProtocol ) {\n\t\t\t\treturn ACCESSOR_MAP[ 1 ]( x, y, fcn, thisArg );\n\t\t\t}\n\t\t\treturn MAP[ 1 ]( x, y, fcn, thisArg );\n\t\t}\n\t\t// At least one ndarray is non-contiguous, so we cannot directly use one-dimensional array functionality...\n\n\t\t// Determine whether we can use simple nested loops...\n\t\tif ( ndims <= MAX_DIMS ) {\n\t\t\t// So long as iteration for each respective array always moves in the same direction (i.e., no mixed sign strides), we can leverage cache-optimal (i.e., normal) nested loops without resorting to blocked iteration...\n\t\t\tif ( x.accessorProtocol || y.accessorProtocol ) {\n\t\t\t\treturn ACCESSOR_MAP[ ndims ]( x, y, fcn, thisArg );\n\t\t\t}\n\t\t\treturn MAP[ ndims ]( x, y, fcn, thisArg );\n\t\t}\n\t\t// Fall-through to blocked iteration...\n\t}\n\t// At this point, we're either dealing with non-contiguous n-dimensional arrays, high dimensional n-dimensional arrays, and/or arrays having differing memory layouts, so our only hope is that we can still perform blocked iteration...\n\n\t// Determine whether we can perform blocked iteration...\n\tif ( ndims <= MAX_DIMS ) {\n\t\tif ( x.accessorProtocol || y.accessorProtocol ) {\n\t\t\treturn BLOCKED_ACCESSOR_MAP[ ndims-2 ]( x, y, fcn, thisArg );\n\t\t}\n\t\treturn BLOCKED_MAP[ ndims-2 ]( x, y, fcn, thisArg );\n\t}\n\t// Fall-through to linear view iteration without regard for how data is stored in memory (i.e., take the slow path)...\n\tif ( x.accessorProtocol || y.accessorProtocol ) {\n\t\treturn accessormapnd( x, y, fcn, thisArg );\n\t}\n\tmapnd( x, y, fcn, thisArg );\n}\n\n\n// EXPORTS //\n\nexport default map;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Applies a callback function to elements in a zero-dimensional input ndarray and assigns results to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {string} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback execution context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* function scale( z ){\n*    return z * 10.0;\n* }\n*\n* // Create a data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0 ] );\n* var ybuf = new Float64Array( 1 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [];\n*\n* // Define the array strides:\n* var sx = [ 0 ];\n* var sy = [ 0 ];\n*\n* // Define the index offset:\n* var ox = 1;\n* var oy = 0;\n*\n* // Create the input and output ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* }\n*\n* // Apply the map function:\n* map0d( x, y, scale, {} );\n*\n* console.log( y.data );\n* // => <Float64Array>[ 20.0 ]\n*/\nfunction map0d( x, y, fcn, thisArg ) {\n\ty.data[ y.offset ] = fcn.call( thisArg, x.data[ x.offset ], [], x.ref );\n}\n\n\n// EXPORTS //\n\nexport default map0d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Applies a callback function to elements in a one-dimensional input ndarray and assigns results to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {string} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback execution context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* function scale( z ) {\n*     return z * 10.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Float64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 4 ];\n*\n* // Define the array strides:\n* var sx = [ 2 ];\n* var sy = [ 1 ];\n*\n* // Define the index offsets:\n* var ox = 1;\n* var oy = 0;\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Apply the map function:\n* map1d( x, y, scale, {} );\n*\n* console.log( y.data );\n* // => <Float64Array>[ 20.0, 40.0, 60.0, 80.0 ]\n*/\nfunction map1d( x, y, fcn, thisArg ) {\n\tvar xbuf;\n\tvar ybuf;\n\tvar dx0;\n\tvar dy0;\n\tvar S0;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables: dimensions and loop offset (pointer) increments...\n\tS0 = x.shape[ 0 ];\n\tdx0 = x.strides[ 0 ];\n\tdy0 = y.strides[ 0 ];\n\n\t// Set the pointers to the first indexed elements in the respective ndarrays...\n\tix = x.offset;\n\tiy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\tybuf[ iy ] = fcn.call( thisArg, xbuf[ ix ], [ i0 ], x.ref );\n\t\tix += dx0;\n\t\tiy += dy0;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default map1d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport zeroTo from '@stdlib/array-base-zero-to';\nimport reverse from '@stdlib/array-base-reverse';\nimport take from '@stdlib/array-base-take-indexed';\n\n\n// MAIN //\n\n/**\n* Applies a callback function to elements in a two-dimensional input ndarray and assigns results to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {string} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback execution context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* function scale( z ) {\n*     return z * 10.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Float64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 1 ];\n* var sy = [ 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 1;\n* var oy = 0;\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Apply the map function:\n* map2d( x, y, scale, {} );\n*\n* console.log( y.data );\n* // => <Float64Array>[ 20.0, 30.0, 60.0, 70.0 ]\n*/\nfunction map2d( x, y, fcn, thisArg ) {\n\tvar xbuf;\n\tvar ybuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dy0;\n\tvar dy1;\n\tvar idx;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar sx;\n\tvar sy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tsy = y.strides;\n\tidx = zeroTo( sh.length );\n\tif ( x.order === 'row-major' ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 1 ];\n\t\tS1 = sh[ 0 ];\n\t\tdx0 = sx[ 1 ];                // offset increment for the outermost loop\n\t\tdx1 = sx[ 0 ] - ( S0*sx[1] ); // offset increment for innermost loop\n\t\tdy0 = sy[ 1 ];\n\t\tdy1 = sy[ 0 ] - ( S0*sy[1] );\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for outermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] ); // offset increment for innermost loop\n\t\tdy0 = sy[ 0 ];\n\t\tdy1 = sy[ 1 ] - ( S0*sx[0] );\n\t\tidx = reverse( idx );\n\t}\n\t// Set the pointer to the first indexed elements in the respective ndarrays...\n\tix = x.offset;\n\tiy = y.offset;\n\n\t// Cache the references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\tybuf[ iy ] = fcn.call( thisArg, xbuf[ ix ], take( [ i1, i0 ], idx ), x.ref ); // eslint-disable-line max-len\n\t\t\tix += dx0;\n\t\t\tiy += dy0;\n\t\t}\n\t\tix += dx1;\n\t\tiy += dy1;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default map2d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport zeroTo from '@stdlib/array-base-zero-to';\nimport reverse from '@stdlib/array-base-reverse';\nimport take from '@stdlib/array-base-take-indexed';\n\n\n// MAIN //\n\n/**\n* Applies a callback function to elements in a three-dimensional input ndarray and assigns results to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {string} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback execution context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* function scale( z ) {\n*     return z * 10.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( 6 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 1 ];\n* var sy = [ 2, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 1;\n* var oy = 0;\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Apply the map function:\n* map3d( x, y, scale, {} );\n*\n* console.log( y.data );\n* // => <Float64Array>[ 20.0, 30.0, 60.0, 70.0, 100.0, 110.0 ]\n*/\nfunction map3d( x, y, fcn, thisArg ) {\n\tvar xbuf;\n\tvar ybuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar idx;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar sx;\n\tvar sy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tsy = y.strides;\n\tidx = zeroTo( sh.length );\n\tif ( x.order === 'row-major' ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 2 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 0 ];\n\t\tdx0 = sx[ 2 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[2] );\n\t\tdx2 = sx[ 0 ] - ( S1*sx[1] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 2 ];\n\t\tdy1 = sy[ 1 ] - ( S0*sy[2] );\n\t\tdy2 = sy[ 0 ] - ( S1*sy[1] );\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 0 ];\n\t\tdy1 = sy[ 1 ] - ( S0*sy[0] );\n\t\tdy2 = sy[ 2 ] - ( S1*sy[1] );\n\t\tidx = reverse( idx );\n\t}\n\t// Set the pointers to the first indexed elements in the respective ndarrays...\n\tix = x.offset;\n\tiy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\tybuf[ iy ] = fcn.call( thisArg, xbuf[ ix ], take( [ i2, i1, i0 ], idx ), x.ref ); // eslint-disable-line max-len\n\t\t\t\tix += dx0;\n\t\t\t\tiy += dy0;\n\t\t\t}\n\t\t\tix += dx1;\n\t\t\tiy += dy1;\n\t\t}\n\t\tix += dx2;\n\t\tiy += dy2;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default map3d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport zeroTo from '@stdlib/array-base-zero-to';\nimport reverse from '@stdlib/array-base-reverse';\nimport take from '@stdlib/array-base-take-indexed';\n\n\n// MAIN //\n\n/**\n* Applies a callback function to elements in a four-dimensional input ndarray and assigns results to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {string} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback execution context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* function scale( z ) {\n*     return z * 10.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( 6 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 4, 4, 1 ];\n* var sy = [ 6, 2, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 1;\n* var oy = 0;\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Apply the map function:\n* map4d( x, y, scale, {} );\n*\n* console.log( y.data );\n* // => <Float64Array>[ 20.0, 30.0, 60.0, 70.0, 100.0, 110.0 ]\n*/\nfunction map4d( x, y, fcn, thisArg ) {\n\tvar xbuf;\n\tvar ybuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar idx;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar sx;\n\tvar sy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tsy = y.strides;\n\tidx = zeroTo( sh.length );\n\tif ( x.order === 'row-major' ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 3 ];\n\t\tS1 = sh[ 2 ];\n\t\tS2 = sh[ 1 ];\n\t\tS3 = sh[ 0 ];\n\t\tdx0 = sx[ 3 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 2 ] - ( S0*sx[3] );\n\t\tdx2 = sx[ 1 ] - ( S1*sx[2] );\n\t\tdx3 = sx[ 0 ] - ( S2*sx[1] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 3 ];\n\t\tdy1 = sy[ 2 ] - ( S0*sy[3] );\n\t\tdy2 = sy[ 1 ] - ( S1*sy[2] );\n\t\tdy3 = sy[ 0 ] - ( S2*sy[1] );\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 0 ];\n\t\tdy1 = sy[ 1 ] - ( S0*sy[0] );\n\t\tdy2 = sy[ 2 ] - ( S1*sy[1] );\n\t\tdy3 = sy[ 3 ] - ( S2*sy[2] );\n\t\tidx = reverse( idx );\n\t}\n\t// Set the pointers to the first indexed elements in the respective ndarrays...\n\tix = x.offset;\n\tiy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\tybuf[ iy ] = fcn.call( thisArg, xbuf[ ix ], take( [ i3, i2, i1, i0 ], idx ), x.ref ); // eslint-disable-line max-len\n\t\t\t\t\tix += dx0;\n\t\t\t\t\tiy += dy0;\n\t\t\t\t}\n\t\t\t\tix += dx1;\n\t\t\t\tiy += dy1;\n\t\t\t}\n\t\t\tix += dx2;\n\t\t\tiy += dy2;\n\t\t}\n\t\tix += dx3;\n\t\tiy += dy3;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default map4d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport zeroTo from '@stdlib/array-base-zero-to';\nimport reverse from '@stdlib/array-base-reverse';\nimport take from '@stdlib/array-base-take-indexed';\n\n\n// MAIN //\n\n/**\n* Applies a callback function to elements in a five-dimensional input ndarray and assigns results to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {string} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback execution context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* function scale( z ) {\n*     return z * 10.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( 6 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 4, 4, 1 ];\n* var sy = [ 6, 6, 2, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 1;\n* var oy = 0;\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Apply the map function:\n* map5d( x, y, scale, {} );\n*\n* console.log( y.data );\n* // => <Float64Array>[ 20.0, 30.0, 60.0, 70.0, 100.0, 110.0 ]\n*/\nfunction map5d( x, y, fcn, thisArg ) {\n\tvar xbuf;\n\tvar ybuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar idx;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar sx;\n\tvar sy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tsy = y.strides;\n\tidx = zeroTo( sh.length );\n\tif ( x.order === 'row-major' ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 4 ];\n\t\tS1 = sh[ 3 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 1 ];\n\t\tS4 = sh[ 0 ];\n\t\tdx0 = sx[ 4 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 3 ] - ( S0*sx[4] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[3] );\n\t\tdx3 = sx[ 1 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 0 ] - ( S3*sx[1] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 4 ];\n\t\tdy1 = sy[ 3 ] - ( S0*sy[4] );\n\t\tdy2 = sy[ 2 ] - ( S1*sy[3] );\n\t\tdy3 = sy[ 1 ] - ( S2*sy[2] );\n\t\tdy4 = sy[ 0 ] - ( S3*sy[1] );\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 0 ];\n\t\tdy1 = sy[ 1 ] - ( S0*sy[0] );\n\t\tdy2 = sy[ 2 ] - ( S1*sy[1] );\n\t\tdy3 = sy[ 3 ] - ( S2*sy[2] );\n\t\tdy4 = sy[ 4 ] - ( S3*sy[3] );\n\t\tidx = reverse( idx );\n\t}\n\t// Set the pointers to the first indexed elements in the respective ndarrays...\n\tix = x.offset;\n\tiy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\tybuf[ iy ] = fcn.call( thisArg, xbuf[ ix ], take( [ i4, i3, i2, i1, i0 ], idx ), x.ref ); // eslint-disable-line max-len\n\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx1;\n\t\t\t\t\tiy += dy1;\n\t\t\t\t}\n\t\t\t\tix += dx2;\n\t\t\t\tiy += dy2;\n\t\t\t}\n\t\t\tix += dx3;\n\t\t\tiy += dy3;\n\t\t}\n\t\tix += dx4;\n\t\tiy += dy4;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default map5d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport zeroTo from '@stdlib/array-base-zero-to';\nimport reverse from '@stdlib/array-base-reverse';\nimport take from '@stdlib/array-base-take-indexed';\n\n\n// MAIN //\n\n/**\n* Applies a callback function to elements in a six-dimensional input ndarray and assigns results to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {string} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback execution context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* function scale( z ) {\n*     return z * 10.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( 6 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 4, 4, 1 ];\n* var sy = [ 6, 6, 6, 2, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 1;\n* var oy = 0;\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Apply the map function:\n* map6d( x, y, scale, {} );\n*\n* console.log( y.data );\n* // => <Float64Array>[ 20.0, 30.0, 60.0, 70.0, 100.0, 110.0 ]\n*/\nfunction map6d( x, y, fcn, thisArg ) {\n\tvar xbuf;\n\tvar ybuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar dy5;\n\tvar idx;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar sx;\n\tvar sy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tsy = y.strides;\n\tidx = zeroTo( sh.length );\n\tif ( x.order === 'row-major' ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 5 ];\n\t\tS1 = sh[ 4 ];\n\t\tS2 = sh[ 3 ];\n\t\tS3 = sh[ 2 ];\n\t\tS4 = sh[ 1 ];\n\t\tS5 = sh[ 0 ];\n\t\tdx0 = sx[ 5 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 4 ] - ( S0*sx[5] );\n\t\tdx2 = sx[ 3 ] - ( S1*sx[4] );\n\t\tdx3 = sx[ 2 ] - ( S2*sx[3] );\n\t\tdx4 = sx[ 1 ] - ( S3*sx[2] );\n\t\tdx5 = sx[ 0 ] - ( S4*sx[1] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 5 ];\n\t\tdy1 = sy[ 4 ] - ( S0*sy[5] );\n\t\tdy2 = sy[ 3 ] - ( S1*sy[4] );\n\t\tdy3 = sy[ 2 ] - ( S2*sy[3] );\n\t\tdy4 = sy[ 1 ] - ( S3*sy[2] );\n\t\tdy5 = sy[ 0 ] - ( S4*sy[1] );\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 5 ] - ( S4*sx[4] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 0 ];\n\t\tdy1 = sy[ 1 ] - ( S0*sy[0] );\n\t\tdy2 = sy[ 2 ] - ( S1*sy[1] );\n\t\tdy3 = sy[ 3 ] - ( S2*sy[2] );\n\t\tdy4 = sy[ 4 ] - ( S3*sy[3] );\n\t\tdy5 = sy[ 5 ] - ( S4*sy[4] );\n\t\tidx = reverse( idx );\n\t}\n\t// Set the pointers to the first indexed elements in the respective ndarrays...\n\tix = x.offset;\n\tiy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\tybuf[ iy ] = fcn.call( thisArg, xbuf[ ix ], take( [ i5, i4, i3, i2, i1, i0 ], idx ), x.ref ); // eslint-disable-line max-len\n\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx2;\n\t\t\t\t\tiy += dy2;\n\t\t\t\t}\n\t\t\t\tix += dx3;\n\t\t\t\tiy += dy3;\n\t\t\t}\n\t\t\tix += dx4;\n\t\t\tiy += dy4;\n\t\t}\n\t\tix += dx5;\n\t\tiy += dy5;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default map6d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport zeroTo from '@stdlib/array-base-zero-to';\nimport reverse from '@stdlib/array-base-reverse';\nimport take from '@stdlib/array-base-take-indexed';\n\n\n// MAIN //\n\n/**\n* Applies a callback function to elements in a seven-dimensional input ndarray and assigns results to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {string} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback execution context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* function scale( z ) {\n*     return z * 10.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( 6 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 4, 4, 1 ];\n* var sy = [ 6, 6, 6, 6, 2, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 1;\n* var oy = 0;\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Apply the map function:\n* map7d( x, y, scale, {} );\n*\n* console.log( y.data );\n* // => <Float64Array>[ 20.0, 30.0, 60.0, 70.0, 100.0, 110.0 ]\n*/\nfunction map7d( x, y, fcn, thisArg ) { // eslint-disable-line max-statements\n\tvar xbuf;\n\tvar ybuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar dy5;\n\tvar dy6;\n\tvar idx;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar sx;\n\tvar sy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tsy = y.strides;\n\tidx = zeroTo( sh.length );\n\tif ( x.order === 'row-major' ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 6 ];\n\t\tS1 = sh[ 5 ];\n\t\tS2 = sh[ 4 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 2 ];\n\t\tS5 = sh[ 1 ];\n\t\tS6 = sh[ 0 ];\n\t\tdx0 = sx[ 6 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 5 ] - ( S0*sx[6] );\n\t\tdx2 = sx[ 4 ] - ( S1*sx[5] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[4] );\n\t\tdx4 = sx[ 2 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 1 ] - ( S4*sx[2] );\n\t\tdx6 = sx[ 0 ] - ( S5*sx[1] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 6 ];\n\t\tdy1 = sy[ 5 ] - ( S0*sy[6] );\n\t\tdy2 = sy[ 4 ] - ( S1*sy[5] );\n\t\tdy3 = sy[ 3 ] - ( S2*sy[4] );\n\t\tdy4 = sy[ 2 ] - ( S3*sy[3] );\n\t\tdy5 = sy[ 1 ] - ( S4*sy[2] );\n\t\tdy6 = sy[ 0 ] - ( S5*sy[1] );\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tS6 = sh[ 6 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 5 ] - ( S4*sx[4] );\n\t\tdx6 = sx[ 6 ] - ( S5*sx[5] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 0 ];\n\t\tdy1 = sy[ 1 ] - ( S0*sy[0] );\n\t\tdy2 = sy[ 2 ] - ( S1*sy[1] );\n\t\tdy3 = sy[ 3 ] - ( S2*sy[2] );\n\t\tdy4 = sy[ 4 ] - ( S3*sy[3] );\n\t\tdy5 = sy[ 5 ] - ( S4*sy[4] );\n\t\tdy6 = sy[ 6 ] - ( S5*sy[5] );\n\t\tidx = reverse( idx );\n\t}\n\t// Set the pointers to the first indexed elements in the respective ndarrays...\n\tix = x.offset;\n\tiy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\tybuf[ iy ] = fcn.call( thisArg, xbuf[ ix ], take( [ i6, i5, i4, i3, i2, i1, i0 ], idx ), x.ref ); // eslint-disable-line max-len\n\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\tiy += dy2;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx3;\n\t\t\t\t\tiy += dy3;\n\t\t\t\t}\n\t\t\t\tix += dx4;\n\t\t\t\tiy += dy4;\n\t\t\t}\n\t\t\tix += dx5;\n\t\t\tiy += dy5;\n\t\t}\n\t\tix += dx6;\n\t\tiy += dy6;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default map7d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport zeroTo from '@stdlib/array-base-zero-to';\nimport reverse from '@stdlib/array-base-reverse';\nimport take from '@stdlib/array-base-take-indexed';\n\n\n// MAIN //\n\n/**\n* Applies a callback function to elements in an eight-dimensional input ndarray and assigns results to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {string} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback execution context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* function scale( z ) {\n*     return z * 10.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( 6 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 4, 4, 1 ];\n* var sy = [ 6, 6, 6, 6, 6, 2, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 1;\n* var oy = 0;\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Apply the map function:\n* map8d( x, y, scale, {} );\n*\n* console.log( y.data );\n* // => <Float64Array>[ 20.0, 30.0, 60.0, 70.0, 100.0, 110.0 ]\n*/\nfunction map8d( x, y, fcn, thisArg ) { // eslint-disable-line max-statements\n\tvar xbuf;\n\tvar ybuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar dy5;\n\tvar dy6;\n\tvar dy7;\n\tvar idx;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar S7;\n\tvar sx;\n\tvar sy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tsy = y.strides;\n\tidx = zeroTo( sh.length );\n\tif ( x.order === 'row-major' ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 7 ];\n\t\tS1 = sh[ 6 ];\n\t\tS2 = sh[ 5 ];\n\t\tS3 = sh[ 4 ];\n\t\tS4 = sh[ 3 ];\n\t\tS5 = sh[ 2 ];\n\t\tS6 = sh[ 1 ];\n\t\tS7 = sh[ 0 ];\n\t\tdx0 = sx[ 7 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 6 ] - ( S0*sx[7] );\n\t\tdx2 = sx[ 5 ] - ( S1*sx[6] );\n\t\tdx3 = sx[ 4 ] - ( S2*sx[5] );\n\t\tdx4 = sx[ 3 ] - ( S3*sx[4] );\n\t\tdx5 = sx[ 2 ] - ( S4*sx[3] );\n\t\tdx6 = sx[ 1 ] - ( S5*sx[2] );\n\t\tdx7 = sx[ 0 ] - ( S6*sx[1] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 7 ];\n\t\tdy1 = sy[ 6 ] - ( S0*sy[7] );\n\t\tdy2 = sy[ 5 ] - ( S1*sy[6] );\n\t\tdy3 = sy[ 4 ] - ( S2*sy[5] );\n\t\tdy4 = sy[ 3 ] - ( S3*sy[4] );\n\t\tdy5 = sy[ 2 ] - ( S4*sy[3] );\n\t\tdy6 = sy[ 1 ] - ( S5*sy[2] );\n\t\tdy7 = sy[ 0 ] - ( S6*sy[1] );\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tS6 = sh[ 6 ];\n\t\tS7 = sh[ 7 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 5 ] - ( S4*sx[4] );\n\t\tdx6 = sx[ 6 ] - ( S5*sx[5] );\n\t\tdx7 = sx[ 7 ] - ( S6*sx[6] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 0 ];\n\t\tdy1 = sy[ 1 ] - ( S0*sy[0] );\n\t\tdy2 = sy[ 2 ] - ( S1*sy[1] );\n\t\tdy3 = sy[ 3 ] - ( S2*sy[2] );\n\t\tdy4 = sy[ 4 ] - ( S3*sy[3] );\n\t\tdy5 = sy[ 5 ] - ( S4*sy[4] );\n\t\tdy6 = sy[ 6 ] - ( S5*sy[5] );\n\t\tdy7 = sy[ 7 ] - ( S6*sy[6] );\n\t\tidx = reverse( idx );\n\t}\n\t// Set the pointers to the first indexed elements in the respective ndarrays...\n\tix = x.offset;\n\tiy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i7 = 0; i7 < S7; i7++ ) {\n\t\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\tybuf[ iy ] = fcn.call( thisArg, xbuf[ ix ], take( [ i7, i6, i5, i4, i3, i2, i1, i0 ], idx ), x.ref ); // eslint-disable-line max-len\n\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\tiy += dy2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\tiy += dy3;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx4;\n\t\t\t\t\tiy += dy4;\n\t\t\t\t}\n\t\t\t\tix += dx5;\n\t\t\t\tiy += dy5;\n\t\t\t}\n\t\t\tix += dx6;\n\t\t\tiy += dy6;\n\t\t}\n\t\tix += dx7;\n\t\tiy += dy7;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default map8d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport zeroTo from '@stdlib/array-base-zero-to';\nimport reverse from '@stdlib/array-base-reverse';\nimport take from '@stdlib/array-base-take-indexed';\n\n\n// MAIN //\n\n/**\n* Applies a callback function to elements in a nine-dimensional input ndarray and assigns results to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {string} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback execution context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* function scale( z ) {\n*     return z * 10.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( 6 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 1, 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 4, 4, 1 ];\n* var sy = [ 6, 6, 6, 6, 6, 6, 2, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 1;\n* var oy = 0;\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Apply the map function:\n* map9d( x, y, scale, {} );\n*\n* console.log( y.data );\n* // => <Float64Array>[ 20.0, 30.0, 60.0, 70.0, 100.0, 110.0 ]\n*/\nfunction map9d( x, y, fcn, thisArg ) { // eslint-disable-line max-statements\n\tvar xbuf;\n\tvar ybuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar dx8;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar dy5;\n\tvar dy6;\n\tvar dy7;\n\tvar dy8;\n\tvar idx;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar S7;\n\tvar S8;\n\tvar sx;\n\tvar sy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tsy = y.strides;\n\tidx = zeroTo( sh.length );\n\tif ( x.order === 'row-major' ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 8 ];\n\t\tS1 = sh[ 7 ];\n\t\tS2 = sh[ 6 ];\n\t\tS3 = sh[ 5 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 3 ];\n\t\tS6 = sh[ 2 ];\n\t\tS7 = sh[ 1 ];\n\t\tS8 = sh[ 0 ];\n\t\tdx0 = sx[ 8 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 7 ] - ( S0*sx[8] );\n\t\tdx2 = sx[ 6 ] - ( S1*sx[7] );\n\t\tdx3 = sx[ 5 ] - ( S2*sx[6] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[5] );\n\t\tdx5 = sx[ 3 ] - ( S4*sx[4] );\n\t\tdx6 = sx[ 2 ] - ( S5*sx[3] );\n\t\tdx7 = sx[ 1 ] - ( S6*sx[2] );\n\t\tdx8 = sx[ 0 ] - ( S7*sx[1] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 8 ];\n\t\tdy1 = sy[ 7 ] - ( S0*sy[8] );\n\t\tdy2 = sy[ 6 ] - ( S1*sy[7] );\n\t\tdy3 = sy[ 5 ] - ( S2*sy[6] );\n\t\tdy4 = sy[ 4 ] - ( S3*sy[5] );\n\t\tdy5 = sy[ 3 ] - ( S4*sy[4] );\n\t\tdy6 = sy[ 2 ] - ( S5*sy[3] );\n\t\tdy7 = sy[ 1 ] - ( S6*sy[2] );\n\t\tdy8 = sy[ 0 ] - ( S7*sy[1] );\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tS6 = sh[ 6 ];\n\t\tS7 = sh[ 7 ];\n\t\tS8 = sh[ 8 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 5 ] - ( S4*sx[4] );\n\t\tdx6 = sx[ 6 ] - ( S5*sx[5] );\n\t\tdx7 = sx[ 7 ] - ( S6*sx[6] );\n\t\tdx8 = sx[ 8 ] - ( S7*sx[7] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 0 ];\n\t\tdy1 = sy[ 1 ] - ( S0*sy[0] );\n\t\tdy2 = sy[ 2 ] - ( S1*sy[1] );\n\t\tdy3 = sy[ 3 ] - ( S2*sy[2] );\n\t\tdy4 = sy[ 4 ] - ( S3*sy[3] );\n\t\tdy5 = sy[ 5 ] - ( S4*sy[4] );\n\t\tdy6 = sy[ 6 ] - ( S5*sy[5] );\n\t\tdy7 = sy[ 7 ] - ( S6*sy[6] );\n\t\tdy8 = sy[ 8 ] - ( S7*sy[7] );\n\t\tidx = reverse( idx );\n\t}\n\t// Set the pointers to the first indexed elements in the respective ndarrays...\n\tix = x.offset;\n\tiy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i8 = 0; i8 < S8; i8++ ) {\n\t\tfor ( i7 = 0; i7 < S7; i7++ ) {\n\t\t\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\t\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\tybuf[ iy ] = fcn.call( thisArg, xbuf[ ix ], take( [ i8, i7, i6, i5, i4, i3, i2, i1, i0 ], idx ), x.ref ); // eslint-disable-line max-len\n\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\tiy += dy2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\tiy += dy3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\tiy += dy4;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx5;\n\t\t\t\t\tiy += dy5;\n\t\t\t\t}\n\t\t\t\tix += dx6;\n\t\t\t\tiy += dy6;\n\t\t\t}\n\t\t\tix += dx7;\n\t\t\tiy += dy7;\n\t\t}\n\t\tix += dx8;\n\t\tiy += dy8;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default map9d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport zeroTo from '@stdlib/array-base-zero-to';\nimport reverse from '@stdlib/array-base-reverse';\nimport take from '@stdlib/array-base-take-indexed';\n\n\n// MAIN //\n\n/**\n* Applies a callback function to elements in a ten-dimensional input ndarray and assigns results to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {string} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback execution context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* function scale( z ) {\n*     return z * 10.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( 6 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 1, 1, 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 12, 4, 4, 1 ];\n* var sy = [ 6, 6, 6, 6, 6, 6, 6, 2, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 1;\n* var oy = 0;\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Apply the map function:\n* map10d( x, y, scale, {} );\n*\n* console.log( y.data );\n* // => <Float64Array>[ 20.0, 30.0, 60.0, 70.0, 100.0, 110.0 ]\n*/\nfunction map10d( x, y, fcn, thisArg ) { // eslint-disable-line max-statements\n\tvar xbuf;\n\tvar ybuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar dx8;\n\tvar dx9;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar dy5;\n\tvar dy6;\n\tvar dy7;\n\tvar dy8;\n\tvar dy9;\n\tvar idx;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar S7;\n\tvar S8;\n\tvar S9;\n\tvar sx;\n\tvar sy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\tvar i9;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tsy = y.strides;\n\tidx = zeroTo( sh.length );\n\tif ( x.order === 'row-major' ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 9 ];\n\t\tS1 = sh[ 8 ];\n\t\tS2 = sh[ 7 ];\n\t\tS3 = sh[ 6 ];\n\t\tS4 = sh[ 5 ];\n\t\tS5 = sh[ 4 ];\n\t\tS6 = sh[ 3 ];\n\t\tS7 = sh[ 2 ];\n\t\tS8 = sh[ 1 ];\n\t\tS9 = sh[ 0 ];\n\t\tdx0 = sx[ 9 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 8 ] - ( S0*sx[9] );\n\t\tdx2 = sx[ 7 ] - ( S1*sx[8] );\n\t\tdx3 = sx[ 6 ] - ( S2*sx[7] );\n\t\tdx4 = sx[ 5 ] - ( S3*sx[6] );\n\t\tdx5 = sx[ 4 ] - ( S4*sx[5] );\n\t\tdx6 = sx[ 3 ] - ( S5*sx[4] );\n\t\tdx7 = sx[ 2 ] - ( S6*sx[3] );\n\t\tdx8 = sx[ 1 ] - ( S7*sx[2] );\n\t\tdx9 = sx[ 0 ] - ( S8*sx[1] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 9 ];\n\t\tdy1 = sy[ 8 ] - ( S0*sy[9] );\n\t\tdy2 = sy[ 7 ] - ( S1*sy[8] );\n\t\tdy3 = sy[ 6 ] - ( S2*sy[7] );\n\t\tdy4 = sy[ 5 ] - ( S3*sy[6] );\n\t\tdy5 = sy[ 4 ] - ( S4*sy[5] );\n\t\tdy6 = sy[ 3 ] - ( S5*sy[4] );\n\t\tdy7 = sy[ 2 ] - ( S6*sy[3] );\n\t\tdy8 = sy[ 1 ] - ( S7*sy[2] );\n\t\tdy9 = sy[ 0 ] - ( S8*sy[1] );\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tS6 = sh[ 6 ];\n\t\tS7 = sh[ 7 ];\n\t\tS8 = sh[ 8 ];\n\t\tS9 = sh[ 9 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 5 ] - ( S4*sx[4] );\n\t\tdx6 = sx[ 6 ] - ( S5*sx[5] );\n\t\tdx7 = sx[ 7 ] - ( S6*sx[6] );\n\t\tdx8 = sx[ 8 ] - ( S7*sx[7] );\n\t\tdx9 = sx[ 9 ] - ( S8*sx[8] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 0 ];\n\t\tdy1 = sy[ 1 ] - ( S0*sy[0] );\n\t\tdy2 = sy[ 2 ] - ( S1*sy[1] );\n\t\tdy3 = sy[ 3 ] - ( S2*sy[2] );\n\t\tdy4 = sy[ 4 ] - ( S3*sy[3] );\n\t\tdy5 = sy[ 5 ] - ( S4*sy[4] );\n\t\tdy6 = sy[ 6 ] - ( S5*sy[5] );\n\t\tdy7 = sy[ 7 ] - ( S6*sy[6] );\n\t\tdy8 = sy[ 8 ] - ( S7*sy[7] );\n\t\tdy9 = sy[ 9 ] - ( S8*sy[8] );\n\t\tidx = reverse( idx );\n\t}\n\t// Set the pointers to the first indexed elements in the respective ndarrays...\n\tix = x.offset;\n\tiy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i9 = 0; i9 < S9; i9++ ) {\n\t\tfor ( i8 = 0; i8 < S8; i8++ ) {\n\t\t\tfor ( i7 = 0; i7 < S7; i7++ ) {\n\t\t\t\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\t\t\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\tybuf[ iy ] = fcn.call( thisArg, xbuf[ ix ], take( [ i9, i8, i7, i6, i5, i4, i3, i2, i1, i0 ], idx ), x.ref ); // eslint-disable-line max-len\n\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\tiy += dy2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\tiy += dy3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\tiy += dy4;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t\tiy += dy5;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx6;\n\t\t\t\t\tiy += dy6;\n\t\t\t\t}\n\t\t\t\tix += dx7;\n\t\t\t\tiy += dy7;\n\t\t\t}\n\t\t\tix += dx8;\n\t\t\tiy += dy8;\n\t\t}\n\t\tix += dx9;\n\t\tiy += dy9;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default map10d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Applies a callback function to elements in a zero-dimensional input ndarray and assigns results to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {Object} y - object containing output ndarray meta data\n* @param {string} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} y.accessors - data buffer accessors\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback execution context\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import Complex64 from '@stdlib/complex-float32-ctor';\n* import realf from '@stdlib/complex-float32-real';\n* import imagf from '@stdlib/complex-float32-imag';\n*\n* function scale( z ) {\n*     return new Complex64( realf(z)*10.0, imagf(z)*10.0 );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var ybuf = new Complex64Array( 2 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [];\n*\n* // Define the array strides:\n* var sx = [ 0 ];\n* var sy = [ 0 ];\n*\n* // Define the index offsets:\n* var ox = 1;\n* var oy = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'ref': null,\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n* var y = {\n*     'dtype': 'complex64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Apply the map function:\n* map0d( x, y, scale, {} );\n*\n* var v = y.data.get( 0 );\n*\n* var re = realf( v );\n* // returns 30.0\n*\n* var im = imagf( v );\n* // returns 40.0\n*/\nfunction map0d( x, y, fcn, thisArg ) {\n\ty.accessors[ 1 ]( y.data, y.offset, fcn.call( thisArg, x.accessors[ 0 ]( x.data, x.offset ), [], x.ref ) ); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nexport default map0d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Applies a callback function to elements in a one-dimensional input ndarray and assigns results to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {string} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback execution context\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import Complex64 from '@stdlib/complex-float32-ctor';\n* import realf from '@stdlib/complex-float32-real';\n* import imagf from '@stdlib/complex-float32-imag';\n*\n* function scale( z ) {\n*     return new Complex64( realf(z)*10.0, imagf(z)*10.0 );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Complex64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 4 ];\n*\n* // Define the array strides:\n* var sx = [ 1 ];\n* var sy = [ 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'ref': null,\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n* var y = {\n*     'dtype': 'complex64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Apply the map function:\n* map1d( x, y, scale, {} );\n*\n* var v = y.data.get( 0 );\n*\n* var re = realf( v );\n* // returns 10.0\n*\n* var im = imagf( v );\n* // returns 20.0\n*/\nfunction map1d( x, y, fcn, thisArg ) {\n\tvar xbuf;\n\tvar ybuf;\n\tvar get;\n\tvar set;\n\tvar dx0;\n\tvar dy0;\n\tvar S0;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables: dimensions and loop offset (pointer) increments...\n\tS0 = x.shape[ 0 ];\n\tdx0 = x.strides[ 0 ];\n\tdy0 = y.strides[ 0 ];\n\n\t// Set the pointers to the first indexed elements in the respective ndarrays...\n\tix = x.offset;\n\tiy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache accessors:\n\tget = x.accessors[ 0 ];\n\tset = y.accessors[ 1 ];\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\tset( ybuf, iy, fcn.call( thisArg, get( xbuf, ix ), [ i0 ], x.ref ) );\n\t\tix += dx0;\n\t\tiy += dy0;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default map1d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport zeroTo from '@stdlib/array-base-zero-to';\nimport reverse from '@stdlib/array-base-reverse';\nimport take from '@stdlib/array-base-take-indexed';\n\n\n// MAIN //\n\n/**\n* Applies a callback function to elements in a two-dimensional input ndarray and assigns results to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {string} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback execution context\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import Complex64 from '@stdlib/complex-float32-ctor';\n* import realf from '@stdlib/complex-float32-real';\n* import imagf from '@stdlib/complex-float32-imag';\n*\n* function scale( z ) {\n*     return new Complex64( realf(z)*10.0, imagf(z)*10.0 );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Complex64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 2, 1 ];\n* var sy = [ 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'ref': null,\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n* var y = {\n*     'dtype': 'complex64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Apply the map function:\n* map2d( x, y, scale, {} );\n*\n* var v = y.data.get( 0 );\n*\n* var re = realf( v );\n* // returns 10.0\n*\n* var im = imagf( v );\n* // returns 20.0\n*/\nfunction map2d( x, y, fcn, thisArg ) {\n\tvar xbuf;\n\tvar ybuf;\n\tvar get;\n\tvar set;\n\tvar dx0;\n\tvar dx1;\n\tvar dy0;\n\tvar dy1;\n\tvar idx;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar sx;\n\tvar sy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tsy = y.strides;\n\tidx = zeroTo( sh.length );\n\tif ( x.order === 'row-major' ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 1 ];\n\t\tS1 = sh[ 0 ];\n\t\tdx0 = sx[ 1 ];                // offset increment for the outermost loop\n\t\tdx1 = sx[ 0 ] - ( S0*sx[1] ); // offset increment for innermost loop\n\t\tdy0 = sy[ 1 ];\n\t\tdy1 = sy[ 0 ] - ( S0*sy[1] );\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for outermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] ); // offset increment for innermost loop\n\t\tdy0 = sy[ 0 ];\n\t\tdy1 = sy[ 1 ] - ( S0*sx[0] );\n\t\tidx = reverse( idx );\n\t}\n\t// Set the pointer to the first indexed elements in the respective ndarrays...\n\tix = x.offset;\n\tiy = y.offset;\n\n\t// Cache the references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache accessors:\n\tget = x.accessors[ 0 ];\n\tset = y.accessors[ 1 ];\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\tset( ybuf, iy, fcn.call( thisArg, get( xbuf, ix ), take( [ i1, i0 ], idx ), x.ref ) ); // eslint-disable-line max-len\n\t\t\tix += dx0;\n\t\t\tiy += dy0;\n\t\t}\n\t\tix += dx1;\n\t\tiy += dy1;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default map2d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport zeroTo from '@stdlib/array-base-zero-to';\nimport reverse from '@stdlib/array-base-reverse';\nimport take from '@stdlib/array-base-take-indexed';\n\n\n// MAIN //\n\n/**\n* Applies a callback function to elements in a three-dimensional input ndarray and assigns results to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {string} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback execution context\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import Complex64 from '@stdlib/complex-float32-ctor';\n* import realf from '@stdlib/complex-float32-real';\n* import imagf from '@stdlib/complex-float32-imag';\n*\n* function scale( z ) {\n*     return new Complex64( realf(z)*10.0, imagf(z)*10.0 );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Complex64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 2, 1 ];\n* var sy = [ 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'ref': null,\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n* var y = {\n*     'dtype': 'complex64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Apply the map function:\n* map3d( x, y, scale, {} );\n*\n* var v = y.data.get( 0 );\n*\n* var re = realf( v );\n* // returns 10.0\n*\n* var im = imagf( v );\n* // returns 20.0\n*/\nfunction map3d( x, y, fcn, thisArg ) {\n\tvar xbuf;\n\tvar ybuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar idx;\n\tvar get;\n\tvar set;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar sx;\n\tvar sy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tsy = y.strides;\n\tidx = zeroTo( sh.length );\n\tif ( x.order === 'row-major' ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 2 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 0 ];\n\t\tdx0 = sx[ 2 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[2] );\n\t\tdx2 = sx[ 0 ] - ( S1*sx[1] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 2 ];\n\t\tdy1 = sy[ 1 ] - ( S0*sy[2] );\n\t\tdy2 = sy[ 0 ] - ( S1*sy[1] );\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 0 ];\n\t\tdy1 = sy[ 1 ] - ( S0*sy[0] );\n\t\tdy2 = sy[ 2 ] - ( S1*sy[1] );\n\t\tidx = reverse( idx );\n\t}\n\t// Set the pointers to the first indexed elements in the respective ndarrays...\n\tix = x.offset;\n\tiy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache accessors:\n\tget = x.accessors[ 0 ];\n\tset = y.accessors[ 1 ];\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\tset( ybuf, iy, fcn.call( thisArg, get( xbuf, ix ), take( [ i2, i1, i0 ], idx ), x.ref ) ); // eslint-disable-line max-len\n\t\t\t\tix += dx0;\n\t\t\t\tiy += dy0;\n\t\t\t}\n\t\t\tix += dx1;\n\t\t\tiy += dy1;\n\t\t}\n\t\tix += dx2;\n\t\tiy += dy2;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default map3d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport zeroTo from '@stdlib/array-base-zero-to';\nimport reverse from '@stdlib/array-base-reverse';\nimport take from '@stdlib/array-base-take-indexed';\n\n\n// MAIN //\n\n/**\n* Applies a callback function to elements in a four-dimensional input ndarray and assigns results to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {string} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback execution context\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import Complex64 from '@stdlib/complex-float32-ctor';\n* import realf from '@stdlib/complex-float32-real';\n* import imagf from '@stdlib/complex-float32-imag';\n*\n* function scale( z ) {\n*     return new Complex64( realf(z)*10.0, imagf(z)*10.0 );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Complex64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 2, 1 ];\n* var sy = [ 4, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'ref': null,\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n* var y = {\n*     'dtype': 'complex64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Apply the map function:\n* map4d( x, y, scale, {} );\n*\n* var v = y.data.get( 0 );\n*\n* var re = realf( v );\n* // returns 10.0\n*\n* var im = imagf( v );\n* // returns 20.0\n*/\nfunction map4d( x, y, fcn, thisArg ) {\n\tvar xbuf;\n\tvar ybuf;\n\tvar get;\n\tvar set;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar idx;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar sx;\n\tvar sy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tsy = y.strides;\n\tidx = zeroTo( sh.length );\n\tif ( x.order === 'row-major' ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 3 ];\n\t\tS1 = sh[ 2 ];\n\t\tS2 = sh[ 1 ];\n\t\tS3 = sh[ 0 ];\n\t\tdx0 = sx[ 3 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 2 ] - ( S0*sx[3] );\n\t\tdx2 = sx[ 1 ] - ( S1*sx[2] );\n\t\tdx3 = sx[ 0 ] - ( S2*sx[1] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 3 ];\n\t\tdy1 = sy[ 2 ] - ( S0*sy[3] );\n\t\tdy2 = sy[ 1 ] - ( S1*sy[2] );\n\t\tdy3 = sy[ 0 ] - ( S2*sy[1] );\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 0 ];\n\t\tdy1 = sy[ 1 ] - ( S0*sy[0] );\n\t\tdy2 = sy[ 2 ] - ( S1*sy[1] );\n\t\tdy3 = sy[ 3 ] - ( S2*sy[2] );\n\t\tidx = reverse( idx );\n\t}\n\t// Set the pointers to the first indexed elements in the respective ndarrays...\n\tix = x.offset;\n\tiy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache accessors:\n\tget = x.accessors[ 0 ];\n\tset = y.accessors[ 1 ];\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\tset( ybuf, iy, fcn.call( thisArg, get( xbuf, ix ), take( [ i3, i2, i1, i0 ], idx ), x.ref ) ); // eslint-disable-line max-len\n\t\t\t\t\tix += dx0;\n\t\t\t\t\tiy += dy0;\n\t\t\t\t}\n\t\t\t\tix += dx1;\n\t\t\t\tiy += dy1;\n\t\t\t}\n\t\t\tix += dx2;\n\t\t\tiy += dy2;\n\t\t}\n\t\tix += dx3;\n\t\tiy += dy3;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default map4d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport zeroTo from '@stdlib/array-base-zero-to';\nimport reverse from '@stdlib/array-base-reverse';\nimport take from '@stdlib/array-base-take-indexed';\n\n\n// MAIN //\n\n/**\n* Applies a callback function to elements in a five-dimensional input ndarray and assigns results to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {string} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback execution context\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import Complex64 from '@stdlib/complex-float32-ctor';\n* import realf from '@stdlib/complex-float32-real';\n* import imagf from '@stdlib/complex-float32-imag';\n*\n* function scale( z ) {\n*     return new Complex64( realf(z)*10.0, imagf(z)*10.0 );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Complex64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 4, 2, 1 ];\n* var sy = [ 4, 4, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'ref': null,\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n* var y = {\n*     'dtype': 'complex64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Apply the map function:\n* map5d( x, y, scale, {} );\n*\n* var v = y.data.get( 0 );\n*\n* var re = realf( v );\n* // returns 10.0\n*\n* var im = imagf( v );\n* // returns 20.0\n*/\nfunction map5d( x, y, fcn, thisArg ) {\n\tvar xbuf;\n\tvar ybuf;\n\tvar get;\n\tvar set;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar idx;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar sx;\n\tvar sy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tsy = y.strides;\n\tidx = zeroTo( sh.length );\n\tif ( x.order === 'row-major' ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 4 ];\n\t\tS1 = sh[ 3 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 1 ];\n\t\tS4 = sh[ 0 ];\n\t\tdx0 = sx[ 4 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 3 ] - ( S0*sx[4] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[3] );\n\t\tdx3 = sx[ 1 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 0 ] - ( S3*sx[1] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 4 ];\n\t\tdy1 = sy[ 3 ] - ( S0*sy[4] );\n\t\tdy2 = sy[ 2 ] - ( S1*sy[3] );\n\t\tdy3 = sy[ 1 ] - ( S2*sy[2] );\n\t\tdy4 = sy[ 0 ] - ( S3*sy[1] );\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 0 ];\n\t\tdy1 = sy[ 1 ] - ( S0*sy[0] );\n\t\tdy2 = sy[ 2 ] - ( S1*sy[1] );\n\t\tdy3 = sy[ 3 ] - ( S2*sy[2] );\n\t\tdy4 = sy[ 4 ] - ( S3*sy[3] );\n\t\tidx = reverse( idx );\n\t}\n\t// Set the pointers to the first indexed elements in the respective ndarrays...\n\tix = x.offset;\n\tiy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache accessors:\n\tget = x.accessors[ 0 ];\n\tset = y.accessors[ 1 ];\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\tset( ybuf, iy, fcn.call( thisArg, get( xbuf, ix ), take( [ i4, i3, i2, i1, i0 ], idx ), x.ref ) ); // eslint-disable-line max-len\n\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx1;\n\t\t\t\t\tiy += dy1;\n\t\t\t\t}\n\t\t\t\tix += dx2;\n\t\t\t\tiy += dy2;\n\t\t\t}\n\t\t\tix += dx3;\n\t\t\tiy += dy3;\n\t\t}\n\t\tix += dx4;\n\t\tiy += dy4;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default map5d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport zeroTo from '@stdlib/array-base-zero-to';\nimport reverse from '@stdlib/array-base-reverse';\nimport take from '@stdlib/array-base-take-indexed';\n\n\n// MAIN //\n\n/**\n* Applies a callback function to elements in a six-dimensional input ndarray and assigns results to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {string} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback execution context\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import Complex64 from '@stdlib/complex-float32-ctor';\n* import realf from '@stdlib/complex-float32-real';\n* import imagf from '@stdlib/complex-float32-imag';\n*\n* function scale( z ) {\n*     return new Complex64( realf(z)*10.0, imagf(z)*10.0 );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Complex64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 1, 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 4, 4, 2, 1 ];\n* var sy = [ 4, 4, 4, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'ref': null,\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n* var y = {\n*     'dtype': 'complex64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Apply the map function:\n* map6d( x, y, scale, {} );\n*\n* var v = y.data.get( 0 );\n*\n* var re = realf( v );\n* // returns 10.0\n*\n* var im = imagf( v );\n* // returns 20.0\n*/\nfunction map6d( x, y, fcn, thisArg ) { // eslint-disable-line max-statements\n\tvar xbuf;\n\tvar ybuf;\n\tvar get;\n\tvar set;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar dy5;\n\tvar idx;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar sx;\n\tvar sy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tsy = y.strides;\n\tidx = zeroTo( sh.length );\n\tif ( x.order === 'row-major' ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 5 ];\n\t\tS1 = sh[ 4 ];\n\t\tS2 = sh[ 3 ];\n\t\tS3 = sh[ 2 ];\n\t\tS4 = sh[ 1 ];\n\t\tS5 = sh[ 0 ];\n\t\tdx0 = sx[ 5 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 4 ] - ( S0*sx[5] );\n\t\tdx2 = sx[ 3 ] - ( S1*sx[4] );\n\t\tdx3 = sx[ 2 ] - ( S2*sx[3] );\n\t\tdx4 = sx[ 1 ] - ( S3*sx[2] );\n\t\tdx5 = sx[ 0 ] - ( S4*sx[1] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 5 ];\n\t\tdy1 = sy[ 4 ] - ( S0*sy[5] );\n\t\tdy2 = sy[ 3 ] - ( S1*sy[4] );\n\t\tdy3 = sy[ 2 ] - ( S2*sy[3] );\n\t\tdy4 = sy[ 1 ] - ( S3*sy[2] );\n\t\tdy5 = sy[ 0 ] - ( S4*sy[1] );\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 5 ] - ( S4*sx[4] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 0 ];\n\t\tdy1 = sy[ 1 ] - ( S0*sy[0] );\n\t\tdy2 = sy[ 2 ] - ( S1*sy[1] );\n\t\tdy3 = sy[ 3 ] - ( S2*sy[2] );\n\t\tdy4 = sy[ 4 ] - ( S3*sy[3] );\n\t\tdy5 = sy[ 5 ] - ( S4*sy[4] );\n\t\tidx = reverse( idx );\n\t}\n\t// Set the pointers to the first indexed elements in the respective ndarrays...\n\tix = x.offset;\n\tiy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache accessors:\n\tget = x.accessors[ 0 ];\n\tset = y.accessors[ 1 ];\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\tset( ybuf, iy, fcn.call( thisArg, get( xbuf, ix ), take( [ i5, i4, i3, i2, i1, i0 ], idx ), x.ref ) ); // eslint-disable-line max-len\n\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx2;\n\t\t\t\t\tiy += dy2;\n\t\t\t\t}\n\t\t\t\tix += dx3;\n\t\t\t\tiy += dy3;\n\t\t\t}\n\t\t\tix += dx4;\n\t\t\tiy += dy4;\n\t\t}\n\t\tix += dx5;\n\t\tiy += dy5;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default map6d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport zeroTo from '@stdlib/array-base-zero-to';\nimport reverse from '@stdlib/array-base-reverse';\nimport take from '@stdlib/array-base-take-indexed';\n\n\n// MAIN //\n\n/**\n* Applies a callback function to elements in a seven-dimensional input ndarray and assigns results to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {string} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback execution context\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import Complex64 from '@stdlib/complex-float32-ctor';\n* import realf from '@stdlib/complex-float32-real';\n* import imagf from '@stdlib/complex-float32-imag';\n*\n* function scale( z ) {\n*     return new Complex64( realf(z)*10.0, imagf(z)*10.0 );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Complex64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 1, 1, 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 4, 4, 4, 2, 1 ];\n* var sy = [ 4, 4, 4, 4, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'ref': null,\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n* var y = {\n*     'dtype': 'complex64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Apply the map function:\n* map7d( x, y, scale, {} );\n*\n* var v = y.data.get( 0 );\n*\n* var re = realf( v );\n* // returns 10.0\n*\n* var im = imagf( v );\n* // returns 20.0\n*/\nfunction map7d( x, y, fcn, thisArg ) { // eslint-disable-line max-statements\n\tvar xbuf;\n\tvar ybuf;\n\tvar get;\n\tvar set;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar dy5;\n\tvar dy6;\n\tvar idx;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar sx;\n\tvar sy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tsy = y.strides;\n\tidx = zeroTo( sh.length );\n\tif ( x.order === 'row-major' ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 6 ];\n\t\tS1 = sh[ 5 ];\n\t\tS2 = sh[ 4 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 2 ];\n\t\tS5 = sh[ 1 ];\n\t\tS6 = sh[ 0 ];\n\t\tdx0 = sx[ 6 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 5 ] - ( S0*sx[6] );\n\t\tdx2 = sx[ 4 ] - ( S1*sx[5] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[4] );\n\t\tdx4 = sx[ 2 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 1 ] - ( S4*sx[2] );\n\t\tdx6 = sx[ 0 ] - ( S5*sx[1] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 6 ];\n\t\tdy1 = sy[ 5 ] - ( S0*sy[6] );\n\t\tdy2 = sy[ 4 ] - ( S1*sy[5] );\n\t\tdy3 = sy[ 3 ] - ( S2*sy[4] );\n\t\tdy4 = sy[ 2 ] - ( S3*sy[3] );\n\t\tdy5 = sy[ 1 ] - ( S4*sy[2] );\n\t\tdy6 = sy[ 0 ] - ( S5*sy[1] );\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tS6 = sh[ 6 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 5 ] - ( S4*sx[4] );\n\t\tdx6 = sx[ 6 ] - ( S5*sx[5] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 0 ];\n\t\tdy1 = sy[ 1 ] - ( S0*sy[0] );\n\t\tdy2 = sy[ 2 ] - ( S1*sy[1] );\n\t\tdy3 = sy[ 3 ] - ( S2*sy[2] );\n\t\tdy4 = sy[ 4 ] - ( S3*sy[3] );\n\t\tdy5 = sy[ 5 ] - ( S4*sy[4] );\n\t\tdy6 = sy[ 6 ] - ( S5*sy[5] );\n\t\tidx = reverse( idx );\n\t}\n\t// Set the pointers to the first indexed elements in the respective ndarrays...\n\tix = x.offset;\n\tiy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache accessors:\n\tget = x.accessors[ 0 ];\n\tset = y.accessors[ 1 ];\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\tset( ybuf, iy, fcn.call( thisArg, get( xbuf, ix ), take( [ i6, i5, i4, i3, i2, i1, i0 ], idx ), x.ref ) ); // eslint-disable-line max-len\n\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\tiy += dy2;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx3;\n\t\t\t\t\tiy += dy3;\n\t\t\t\t}\n\t\t\t\tix += dx4;\n\t\t\t\tiy += dy4;\n\t\t\t}\n\t\t\tix += dx5;\n\t\t\tiy += dy5;\n\t\t}\n\t\tix += dx6;\n\t\tiy += dy6;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default map7d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport zeroTo from '@stdlib/array-base-zero-to';\nimport reverse from '@stdlib/array-base-reverse';\nimport take from '@stdlib/array-base-take-indexed';\n\n\n// MAIN //\n\n/**\n* Applies a callback function to elements in an eight-dimensional input ndarray and assigns results to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {string} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback execution context\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import Complex64 from '@stdlib/complex-float32-ctor';\n* import realf from '@stdlib/complex-float32-real';\n* import imagf from '@stdlib/complex-float32-imag';\n*\n* function scale( z ) {\n*     return new Complex64( realf(z)*10.0, imagf(z)*10.0 );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Complex64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 1, 1, 1, 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 4, 4, 4, 4, 2, 1 ];\n* var sy = [ 4, 4, 4, 4, 4, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'ref': null,\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n* var y = {\n*     'dtype': 'complex64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Apply the map function:\n* map8d( x, y, scale, {} );\n*\n* var v = y.data.get( 0 );\n*\n* var re = realf( v );\n* // returns 10.0\n*\n* var im = imagf( v );\n* // returns 20.0\n*/\nfunction map8d( x, y, fcn, thisArg ) { // eslint-disable-line max-statements\n\tvar xbuf;\n\tvar ybuf;\n\tvar get;\n\tvar set;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar dy5;\n\tvar dy6;\n\tvar dy7;\n\tvar idx;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar S7;\n\tvar sx;\n\tvar sy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tsy = y.strides;\n\tidx = zeroTo( sh.length );\n\tif ( x.order === 'row-major' ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 7 ];\n\t\tS1 = sh[ 6 ];\n\t\tS2 = sh[ 5 ];\n\t\tS3 = sh[ 4 ];\n\t\tS4 = sh[ 3 ];\n\t\tS5 = sh[ 2 ];\n\t\tS6 = sh[ 1 ];\n\t\tS7 = sh[ 0 ];\n\t\tdx0 = sx[ 7 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 6 ] - ( S0*sx[7] );\n\t\tdx2 = sx[ 5 ] - ( S1*sx[6] );\n\t\tdx3 = sx[ 4 ] - ( S2*sx[5] );\n\t\tdx4 = sx[ 3 ] - ( S3*sx[4] );\n\t\tdx5 = sx[ 2 ] - ( S4*sx[3] );\n\t\tdx6 = sx[ 1 ] - ( S5*sx[2] );\n\t\tdx7 = sx[ 0 ] - ( S6*sx[1] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 7 ];\n\t\tdy1 = sy[ 6 ] - ( S0*sy[7] );\n\t\tdy2 = sy[ 5 ] - ( S1*sy[6] );\n\t\tdy3 = sy[ 4 ] - ( S2*sy[5] );\n\t\tdy4 = sy[ 3 ] - ( S3*sy[4] );\n\t\tdy5 = sy[ 2 ] - ( S4*sy[3] );\n\t\tdy6 = sy[ 1 ] - ( S5*sy[2] );\n\t\tdy7 = sy[ 0 ] - ( S6*sy[1] );\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tS6 = sh[ 6 ];\n\t\tS7 = sh[ 7 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 5 ] - ( S4*sx[4] );\n\t\tdx6 = sx[ 6 ] - ( S5*sx[5] );\n\t\tdx7 = sx[ 7 ] - ( S6*sx[6] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 0 ];\n\t\tdy1 = sy[ 1 ] - ( S0*sy[0] );\n\t\tdy2 = sy[ 2 ] - ( S1*sy[1] );\n\t\tdy3 = sy[ 3 ] - ( S2*sy[2] );\n\t\tdy4 = sy[ 4 ] - ( S3*sy[3] );\n\t\tdy5 = sy[ 5 ] - ( S4*sy[4] );\n\t\tdy6 = sy[ 6 ] - ( S5*sy[5] );\n\t\tdy7 = sy[ 7 ] - ( S6*sy[6] );\n\t\tidx = reverse( idx );\n\t}\n\t// Set the pointers to the first indexed elements in the respective ndarrays...\n\tix = x.offset;\n\tiy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache accessors:\n\tget = x.accessors[ 0 ];\n\tset = y.accessors[ 1 ];\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i7 = 0; i7 < S7; i7++ ) {\n\t\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\tset( ybuf, iy, fcn.call( thisArg, get( xbuf, ix ), take( [ i7, i6, i5, i4, i3, i2, i1, i0 ], idx ), x.ref ) ); // eslint-disable-line max-len\n\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\tiy += dy2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\tiy += dy3;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx4;\n\t\t\t\t\tiy += dy4;\n\t\t\t\t}\n\t\t\t\tix += dx5;\n\t\t\t\tiy += dy5;\n\t\t\t}\n\t\t\tix += dx6;\n\t\t\tiy += dy6;\n\t\t}\n\t\tix += dx7;\n\t\tiy += dy7;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default map8d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport zeroTo from '@stdlib/array-base-zero-to';\nimport reverse from '@stdlib/array-base-reverse';\nimport take from '@stdlib/array-base-take-indexed';\n\n\n// MAIN //\n\n/**\n* Applies a callback function to elements in a nine-dimensional input ndarray and assigns results to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {string} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback execution context\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import Complex64 from '@stdlib/complex-float32-ctor';\n* import realf from '@stdlib/complex-float32-real';\n* import imagf from '@stdlib/complex-float32-imag';\n*\n* function scale( z ) {\n*     return new Complex64( realf(z)*10.0, imagf(z)*10.0 );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Complex64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 1, 1, 1, 1, 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 4, 4, 4, 4, 4, 2, 1 ];\n* var sy = [ 4, 4, 4, 4, 4, 4, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'ref': null,\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n* var y = {\n*     'dtype': 'complex64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Apply the map function:\n* map9d( x, y, scale, {} );\n*\n* var v = y.data.get( 0 );\n*\n* var re = realf( v );\n* // returns 10.0\n*\n* var im = imagf( v );\n* // returns 20.0\n*/\nfunction map9d( x, y, fcn, thisArg ) { // eslint-disable-line max-statements\n\tvar xbuf;\n\tvar ybuf;\n\tvar get;\n\tvar set;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar dx8;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar dy5;\n\tvar dy6;\n\tvar dy7;\n\tvar dy8;\n\tvar idx;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar S7;\n\tvar S8;\n\tvar sx;\n\tvar sy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tsy = y.strides;\n\tidx = zeroTo( sh.length );\n\tif ( x.order === 'row-major' ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 8 ];\n\t\tS1 = sh[ 7 ];\n\t\tS2 = sh[ 6 ];\n\t\tS3 = sh[ 5 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 3 ];\n\t\tS6 = sh[ 2 ];\n\t\tS7 = sh[ 1 ];\n\t\tS8 = sh[ 0 ];\n\t\tdx0 = sx[ 8 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 7 ] - ( S0*sx[8] );\n\t\tdx2 = sx[ 6 ] - ( S1*sx[7] );\n\t\tdx3 = sx[ 5 ] - ( S2*sx[6] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[5] );\n\t\tdx5 = sx[ 3 ] - ( S4*sx[4] );\n\t\tdx6 = sx[ 2 ] - ( S5*sx[3] );\n\t\tdx7 = sx[ 1 ] - ( S6*sx[2] );\n\t\tdx8 = sx[ 0 ] - ( S7*sx[1] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 8 ];\n\t\tdy1 = sy[ 7 ] - ( S0*sy[8] );\n\t\tdy2 = sy[ 6 ] - ( S1*sy[7] );\n\t\tdy3 = sy[ 5 ] - ( S2*sy[6] );\n\t\tdy4 = sy[ 4 ] - ( S3*sy[5] );\n\t\tdy5 = sy[ 3 ] - ( S4*sy[4] );\n\t\tdy6 = sy[ 2 ] - ( S5*sy[3] );\n\t\tdy7 = sy[ 1 ] - ( S6*sy[2] );\n\t\tdy8 = sy[ 0 ] - ( S7*sy[1] );\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tS6 = sh[ 6 ];\n\t\tS7 = sh[ 7 ];\n\t\tS8 = sh[ 8 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 5 ] - ( S4*sx[4] );\n\t\tdx6 = sx[ 6 ] - ( S5*sx[5] );\n\t\tdx7 = sx[ 7 ] - ( S6*sx[6] );\n\t\tdx8 = sx[ 8 ] - ( S7*sx[7] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 0 ];\n\t\tdy1 = sy[ 1 ] - ( S0*sy[0] );\n\t\tdy2 = sy[ 2 ] - ( S1*sy[1] );\n\t\tdy3 = sy[ 3 ] - ( S2*sy[2] );\n\t\tdy4 = sy[ 4 ] - ( S3*sy[3] );\n\t\tdy5 = sy[ 5 ] - ( S4*sy[4] );\n\t\tdy6 = sy[ 6 ] - ( S5*sy[5] );\n\t\tdy7 = sy[ 7 ] - ( S6*sy[6] );\n\t\tdy8 = sy[ 8 ] - ( S7*sy[7] );\n\t\tidx = reverse( idx );\n\t}\n\t// Set the pointers to the first indexed elements in the respective ndarrays...\n\tix = x.offset;\n\tiy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache accessors:\n\tget = x.accessors[ 0 ];\n\tset = y.accessors[ 1 ];\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i8 = 0; i8 < S8; i8++ ) {\n\t\tfor ( i7 = 0; i7 < S7; i7++ ) {\n\t\t\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\t\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\tset( ybuf, iy, fcn.call( thisArg, get( xbuf, ix ), take( [ i8, i7, i6, i5, i4, i3, i2, i1, i0 ], idx ), x.ref ) ); // eslint-disable-line max-len\n\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\tiy += dy2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\tiy += dy3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\tiy += dy4;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx5;\n\t\t\t\t\tiy += dy5;\n\t\t\t\t}\n\t\t\t\tix += dx6;\n\t\t\t\tiy += dy6;\n\t\t\t}\n\t\t\tix += dx7;\n\t\t\tiy += dy7;\n\t\t}\n\t\tix += dx8;\n\t\tiy += dy8;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default map9d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport zeroTo from '@stdlib/array-base-zero-to';\nimport reverse from '@stdlib/array-base-reverse';\nimport take from '@stdlib/array-base-take-indexed';\n\n\n// MAIN //\n\n/**\n* Applies a callback function to elements in a ten-dimensional input ndarray and assigns results to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {string} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback execution context\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import Complex64 from '@stdlib/complex-float32-ctor';\n* import realf from '@stdlib/complex-float32-real';\n* import imagf from '@stdlib/complex-float32-imag';\n*\n* function scale( z ) {\n*     return new Complex64( realf(z)*10.0, imagf(z)*10.0 );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Complex64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 1, 1, 1, 1, 1, 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 4, 4, 4, 4, 4, 4, 2, 1 ];\n* var sy = [ 4, 4, 4, 4, 4, 4, 4, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'ref': null,\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n* var y = {\n*     'dtype': 'complex64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Apply the map function:\n* map10d( x, y, scale, {} );\n*\n* var v = y.data.get( 0 );\n*\n* var re = realf( v );\n* // returns 10.0\n*\n* var im = imagf( v );\n* // returns 20.0\n*/\nfunction map10d( x, y, fcn, thisArg ) { // eslint-disable-line max-statements\n\tvar xbuf;\n\tvar ybuf;\n\tvar get;\n\tvar set;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar dx8;\n\tvar dx9;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar dy5;\n\tvar dy6;\n\tvar dy7;\n\tvar dy8;\n\tvar dy9;\n\tvar idx;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar S7;\n\tvar S8;\n\tvar S9;\n\tvar sx;\n\tvar sy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\tvar i9;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tsy = y.strides;\n\tidx = zeroTo( sh.length );\n\tif ( x.order === 'row-major' ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 9 ];\n\t\tS1 = sh[ 8 ];\n\t\tS2 = sh[ 7 ];\n\t\tS3 = sh[ 6 ];\n\t\tS4 = sh[ 5 ];\n\t\tS5 = sh[ 4 ];\n\t\tS6 = sh[ 3 ];\n\t\tS7 = sh[ 2 ];\n\t\tS8 = sh[ 1 ];\n\t\tS9 = sh[ 0 ];\n\t\tdx0 = sx[ 9 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 8 ] - ( S0*sx[9] );\n\t\tdx2 = sx[ 7 ] - ( S1*sx[8] );\n\t\tdx3 = sx[ 6 ] - ( S2*sx[7] );\n\t\tdx4 = sx[ 5 ] - ( S3*sx[6] );\n\t\tdx5 = sx[ 4 ] - ( S4*sx[5] );\n\t\tdx6 = sx[ 3 ] - ( S5*sx[4] );\n\t\tdx7 = sx[ 2 ] - ( S6*sx[3] );\n\t\tdx8 = sx[ 1 ] - ( S7*sx[2] );\n\t\tdx9 = sx[ 0 ] - ( S8*sx[1] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 9 ];\n\t\tdy1 = sy[ 8 ] - ( S0*sy[9] );\n\t\tdy2 = sy[ 7 ] - ( S1*sy[8] );\n\t\tdy3 = sy[ 6 ] - ( S2*sy[7] );\n\t\tdy4 = sy[ 5 ] - ( S3*sy[6] );\n\t\tdy5 = sy[ 4 ] - ( S4*sy[5] );\n\t\tdy6 = sy[ 3 ] - ( S5*sy[4] );\n\t\tdy7 = sy[ 2 ] - ( S6*sy[3] );\n\t\tdy8 = sy[ 1 ] - ( S7*sy[2] );\n\t\tdy9 = sy[ 0 ] - ( S8*sy[1] );\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tS6 = sh[ 6 ];\n\t\tS7 = sh[ 7 ];\n\t\tS8 = sh[ 8 ];\n\t\tS9 = sh[ 9 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 5 ] - ( S4*sx[4] );\n\t\tdx6 = sx[ 6 ] - ( S5*sx[5] );\n\t\tdx7 = sx[ 7 ] - ( S6*sx[6] );\n\t\tdx8 = sx[ 8 ] - ( S7*sx[7] );\n\t\tdx9 = sx[ 9 ] - ( S8*sx[8] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 0 ];\n\t\tdy1 = sy[ 1 ] - ( S0*sy[0] );\n\t\tdy2 = sy[ 2 ] - ( S1*sy[1] );\n\t\tdy3 = sy[ 3 ] - ( S2*sy[2] );\n\t\tdy4 = sy[ 4 ] - ( S3*sy[3] );\n\t\tdy5 = sy[ 5 ] - ( S4*sy[4] );\n\t\tdy6 = sy[ 6 ] - ( S5*sy[5] );\n\t\tdy7 = sy[ 7 ] - ( S6*sy[6] );\n\t\tdy8 = sy[ 8 ] - ( S7*sy[7] );\n\t\tdy9 = sy[ 9 ] - ( S8*sy[8] );\n\t\tidx = reverse( idx );\n\t}\n\t// Set the pointers to the first indexed elements in the respective ndarrays...\n\tix = x.offset;\n\tiy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache accessors:\n\tget = x.accessors[ 0 ];\n\tset = y.accessors[ 1 ];\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i9 = 0; i9 < S9; i9++ ) {\n\t\tfor ( i8 = 0; i8 < S8; i8++ ) {\n\t\t\tfor ( i7 = 0; i7 < S7; i7++ ) {\n\t\t\t\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\t\t\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\tset( ybuf, iy, fcn.call( thisArg, get( xbuf, ix ), take( [ i9, i8, i7, i6, i5, i4, i3, i2, i1, i0 ], idx ), x.ref ) ); // eslint-disable-line max-len\n\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\tiy += dy2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\tiy += dy3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\tiy += dy4;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t\tiy += dy5;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx6;\n\t\t\t\t\tiy += dy6;\n\t\t\t\t}\n\t\t\t\tix += dx7;\n\t\t\t\tiy += dy7;\n\t\t\t}\n\t\t\tix += dx8;\n\t\t\tiy += dy8;\n\t\t}\n\t\tix += dx9;\n\t\tiy += dy9;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default map10d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\nimport take from '@stdlib/array-base-take-indexed';\nimport reverse from '@stdlib/array-base-reverse';\n\n\n// MAIN //\n\n/**\n* Applies a callback function to elements in a two-dimensional input ndarray and assigns results to elements in an equivalently shaped output ndarray via loop blocking.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {string} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback execution context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* function scale( z ) {\n*     return z * 10.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Float64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 1 ];\n* var sy = [ 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 1;\n* var oy = 0;\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Apply the map function:\n* blockedmap2d( x, y, scale, {} );\n*\n* console.log( y.data );\n* // => <Float64Array>[ 20.0, 30.0, 60.0, 70.0 ]\n*/\nfunction blockedmap2d( x, y, fcn, thisArg ) {\n\tvar bsize;\n\tvar xbuf;\n\tvar ybuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dy0;\n\tvar dy1;\n\tvar ox1;\n\tvar oy1;\n\tvar idx;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar sx;\n\tvar sy;\n\tvar ox;\n\tvar oy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar j0;\n\tvar j1;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides, y.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tsy = o.sy;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Cache the indices of the first indexed elements in the respective ndarrays...\n\tox = x.offset;\n\toy = y.offset;\n\n\t// Cache the references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache offset increments for the innermost loop...\n\tdx0 = sx[0];\n\tdy0 = sy[0];\n\n\t// Iterate over blocks...\n\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\tif ( j1 < bsize ) {\n\t\t\ts1 = j1;\n\t\t\tj1 = 0;\n\t\t} else {\n\t\t\ts1 = bsize;\n\t\t\tj1 -= bsize;\n\t\t}\n\t\tox1 = ox + ( j1*sx[1] );\n\t\toy1 = oy + ( j1*sy[1] );\n\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\tif ( j0 < bsize ) {\n\t\t\t\ts0 = j0;\n\t\t\t\tj0 = 0;\n\t\t\t} else {\n\t\t\t\ts0 = bsize;\n\t\t\t\tj0 -= bsize;\n\t\t\t}\n\t\t\t// Compute the index offsets for the first input and output ndarray elements in the current block...\n\t\t\tix = ox1 + (j0*sx[0]);\n\t\t\tiy = oy1 + (j0*sy[0]);\n\n\t\t\t// Compute the loop offset increments...\n\t\t\tdx1 = sx[1] - (s0*sx[0]);\n\t\t\tdy1 = sy[1] - (s0*sy[0]);\n\n\t\t\t// Iterate over the ndarray dimensions...\n\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\tybuf[ iy ] = fcn.call( thisArg, xbuf[ ix ], take( [ i1, i0 ], idx ), x.ref ); // eslint-disable-line max-len\n\t\t\t\t\tix += dx0;\n\t\t\t\t\tiy += dy0;\n\t\t\t\t}\n\t\t\t\tix += dx1;\n\t\t\t\tiy += dy1;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedmap2d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\nimport take from '@stdlib/array-base-take-indexed';\nimport reverse from '@stdlib/array-base-reverse';\n\n\n// MAIN //\n\n/**\n* Applies a callback function to elements in a three-dimensional input ndarray and assigns results to elements in an equivalently shaped output ndarray via loop blocking.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {string} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback execution context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* function scale( x ) {\n*     return x * 10.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( 6 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 1 ];\n* var sy = [ 2, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 1;\n* var oy = 0;\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Apply the map function:\n* blockedmap3d( x, y, scale, {} );\n*\n* console.log( y.data );\n* // => <Float64Array>[ 20.0, 30.0, 60.0, 70.0, 100.0, 110.0 ]\n*/\nfunction blockedmap3d( x, y, fcn, thisArg ) {\n\tvar bsize;\n\tvar xbuf;\n\tvar ybuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar ox1;\n\tvar ox2;\n\tvar oy1;\n\tvar oy2;\n\tvar idx;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar sx;\n\tvar sy;\n\tvar ox;\n\tvar oy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides, y.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tsy = o.sy;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Cache the indices of the first indexed elements in the respective ndarrays...\n\tox = x.offset;\n\toy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache offset increments for the innermost loop...\n\tdx0 = sx[0];\n\tdy0 = sy[0];\n\n\t// Iterate over blocks...\n\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\tif ( j2 < bsize ) {\n\t\t\ts2 = j2;\n\t\t\tj2 = 0;\n\t\t} else {\n\t\t\ts2 = bsize;\n\t\t\tj2 -= bsize;\n\t\t}\n\t\tox2 = ox + ( j2*sx[2] );\n\t\toy2 = oy + ( j2*sy[2] );\n\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\tif ( j1 < bsize ) {\n\t\t\t\ts1 = j1;\n\t\t\t\tj1 = 0;\n\t\t\t} else {\n\t\t\t\ts1 = bsize;\n\t\t\t\tj1 -= bsize;\n\t\t\t}\n\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\tdy2 = sy[2] - ( s1*sy[1] );\n\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\toy1 = oy2 + ( j1*sy[1] );\n\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\ts0 = j0;\n\t\t\t\t\tj0 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts0 = bsize;\n\t\t\t\t\tj0 -= bsize;\n\t\t\t\t}\n\t\t\t\t// Compute index offsets for the first input and output ndarray elements in the current block...\n\t\t\t\tix = ox1 + ( j0*sx[0] );\n\t\t\t\tiy = oy1 + ( j0*sy[0] );\n\n\t\t\t\t// Compute loop offset increments...\n\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\t\t\t\tdy1 = sy[1] - ( s0*sy[0] );\n\n\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\tybuf[ iy ] = fcn.call( thisArg, xbuf[ ix ], take( [ i2, i1, i0 ], idx ), x.ref ); // eslint-disable-line max-len\n\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx2;\n\t\t\t\t\tiy += dy2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedmap3d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\nimport take from '@stdlib/array-base-take-indexed';\nimport reverse from '@stdlib/array-base-reverse';\n\n\n// MAIN //\n\n/**\n* Applies a callback function to elements in a four-dimensional input ndarray and assigns results to elements in an equivalently shaped output ndarray via loop blocking.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {string} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback execution context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* function scale( x ) {\n*     return x * 10.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( 6 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 4, 4, 1 ];\n* var sy = [ 6, 2, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 1;\n* var oy = 0;\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Apply the map function:\n* blockedmap4d( x, y, scale, {} );\n*\n* console.log( y.data );\n* // => <Float64Array>[ 20.0, 30.0, 60.0, 70.0, 100.0, 110.0 ]\n*/\nfunction blockedmap4d( x, y, fcn, thisArg ) { // eslint-disable-line max-statements\n\tvar bsize;\n\tvar xbuf;\n\tvar ybuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar idx;\n\tvar oy1;\n\tvar oy2;\n\tvar oy3;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar sx;\n\tvar sy;\n\tvar ox;\n\tvar oy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides, y.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tsy = o.sy;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Cache the indices of the first indexed elements in the respective ndarrays...\n\tox = x.offset;\n\toy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache offset increments for the innermost loop...\n\tdx0 = sx[0];\n\tdy0 = sy[0];\n\n\t// Iterate over blocks...\n\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\tif ( j3 < bsize ) {\n\t\t\tS3 = j3;\n\t\t\tj3 = 0;\n\t\t} else {\n\t\t\tS3 = bsize;\n\t\t\tj3 -= bsize;\n\t\t}\n\t\tox3 = ox + ( j3*sx[3] );\n\t\toy3 = oy + ( j3*sy[3] );\n\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\tif ( j2 < bsize ) {\n\t\t\t\tS2 = j2;\n\t\t\t\tj2 = 0;\n\t\t\t} else {\n\t\t\t\tS2 = bsize;\n\t\t\t\tj2 -= bsize;\n\t\t\t}\n\t\t\tdx3 = sx[3] - ( S2*sx[2] );\n\t\t\tdy3 = sy[3] - ( S2*sy[2] );\n\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\toy2 = oy3 + ( j2*sy[2] );\n\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\tS1 = j1;\n\t\t\t\t\tj1 = 0;\n\t\t\t\t} else {\n\t\t\t\t\tS1 = bsize;\n\t\t\t\t\tj1 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx2 = sx[2] - ( S1*sx[1] );\n\t\t\t\tdy2 = sy[2] - ( S1*sy[1] );\n\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\toy1 = oy2 + ( j1*sy[1] );\n\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\tS0 = j0;\n\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tS0 = bsize;\n\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\t// Compute index offsets for the first input and output ndarray elements in the current block...\n\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\t\t\t\t\tiy = oy1 + ( j0*sy[0] );\n\n\t\t\t\t\t// Compute loop offset increments...\n\t\t\t\t\tdx1 = sx[1] - ( S0*sx[0] );\n\t\t\t\t\tdy1 = sy[1] - ( S0*sy[0] );\n\n\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\tybuf[ iy ] = fcn.call( thisArg, xbuf[ ix ], take( [ i3, i2, i1, i0 ], idx ), x.ref ); // eslint-disable-line max-len\n\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\tiy += dy2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\tiy += dy3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedmap4d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\nimport take from '@stdlib/array-base-take-indexed';\nimport reverse from '@stdlib/array-base-reverse';\n\n\n// MAIN //\n\n/**\n* Applies a callback function to elements in a five-dimensional input ndarray and assigns results to elements in an equivalently shaped output ndarray via loop blocking.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {string} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback execution context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* function scale( z ) {\n*     return z * 10.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( 6 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 4, 4, 1 ];\n* var sy = [ 6, 6, 2, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 1;\n* var oy = 0;\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Apply the map function:\n* blockedmap5d( x, y, scale, {} );\n*\n* console.log( y.data );\n* // => <Float64Array>[ 20.0, 30.0, 60.0, 70.0, 100.0, 110.0 ]\n*/\nfunction blockedmap5d( x, y, fcn, thisArg ) { // eslint-disable-line max-statements\n\tvar bsize;\n\tvar xbuf;\n\tvar ybuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar idx;\n\tvar oy1;\n\tvar oy2;\n\tvar oy3;\n\tvar oy4;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar sx;\n\tvar sy;\n\tvar ox;\n\tvar oy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides, y.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tsy = o.sy;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Cache the indices of the first indexed elements in the respective ndarrays...\n\tox = x.offset;\n\toy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache offset increments for the innermost loop...\n\tdx0 = sx[0];\n\tdy0 = sy[0];\n\n\t// Iterate over blocks...\n\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\tif ( j4 < bsize ) {\n\t\t\tS4 = j4;\n\t\t\tj4 = 0;\n\t\t} else {\n\t\t\tS4 = bsize;\n\t\t\tj4 -= bsize;\n\t\t}\n\t\tox4 = ox + ( j4*sx[4] );\n\t\toy4 = oy + ( j4*sy[4] );\n\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\tif ( j3 < bsize ) {\n\t\t\t\tS3 = j3;\n\t\t\t\tj3 = 0;\n\t\t\t} else {\n\t\t\t\tS3 = bsize;\n\t\t\t\tj3 -= bsize;\n\t\t\t}\n\t\t\tdx4 = sx[4] - ( S3*sx[3] );\n\t\t\tdy4 = sy[4] - ( S3*sy[3] );\n\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\toy3 = oy4 + ( j3*sy[3] );\n\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\tS2 = j2;\n\t\t\t\t\tj2 = 0;\n\t\t\t\t} else {\n\t\t\t\t\tS2 = bsize;\n\t\t\t\t\tj2 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx3 = sx[3] - ( S2*sx[2] );\n\t\t\t\tdy3 = sy[3] - ( S2*sy[2] );\n\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\toy2 = oy3 + ( j2*sy[2] );\n\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\tS1 = j1;\n\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tS1 = bsize;\n\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx2 = sx[2] - ( S1*sx[1] );\n\t\t\t\t\tdy2 = sy[2] - ( S1*sy[1] );\n\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\toy1 = oy2 + ( j1*sy[1] );\n\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\tS0 = j0;\n\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tS0 = bsize;\n\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Compute index offsets for the first input and output ndarray elements in the current block...\n\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\t\t\t\t\t\tiy = oy1 + ( j0*sy[0] );\n\n\t\t\t\t\t\t// Compute loop offset increments...\n\t\t\t\t\t\tdx1 = sx[1] - ( S0*sx[0] );\n\t\t\t\t\t\tdy1 = sy[1] - ( S0*sy[0] );\n\n\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\tybuf[ iy ] = fcn.call( thisArg, xbuf[ ix ], take( [ i4, i3, i2, i1, i0 ], idx ), x.ref ); // eslint-disable-line max-len\n\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\tiy += dy2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\tiy += dy3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\tiy += dy4;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedmap5d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\nimport take from '@stdlib/array-base-take-indexed';\nimport reverse from '@stdlib/array-base-reverse';\n\n\n// MAIN //\n\n/**\n* Applies a callback function to elements in a six-dimensional input ndarray and assigns results to elements in an equivalently shaped output ndarray via loop blocking.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {string} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback execution context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* function scale( z ) {\n*     return z * 10.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( 6 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 4, 4, 1 ];\n* var sy = [ 6, 6, 6, 2, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 1;\n* var oy = 0;\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Apply the map function:\n* blockedmap6d( x, y, scale, {} );\n*\n* console.log( y.data );\n* // => <Float64Array>[ 20.0, 30.0, 60.0, 70.0, 100.0, 110.0 ]\n*/\nfunction blockedmap6d( x, y, fcn, thisArg ) { // eslint-disable-line max-statements\n\tvar bsize;\n\tvar xbuf;\n\tvar ybuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar dy5;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar ox5;\n\tvar oy1;\n\tvar oy2;\n\tvar oy3;\n\tvar oy4;\n\tvar oy5;\n\tvar idx;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar sx;\n\tvar sy;\n\tvar ox;\n\tvar oy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides, y.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tsy = o.sy;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Cache the indices of the first indexed elements in the respective ndarrays...\n\tox = x.offset;\n\toy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache offset increments for the innermost loop...\n\tdx0 = sx[0];\n\tdy0 = sy[0];\n\n\t// Iterate over blocks...\n\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\tif ( j5 < bsize ) {\n\t\t\tS5 = j5;\n\t\t\tj5 = 0;\n\t\t} else {\n\t\t\tS5 = bsize;\n\t\t\tj5 -= bsize;\n\t\t}\n\t\tox5 = ox + ( j5*sx[5] );\n\t\toy5 = oy + ( j5*sy[5] );\n\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\tif ( j4 < bsize ) {\n\t\t\t\tS4 = j4;\n\t\t\t\tj4 = 0;\n\t\t\t} else {\n\t\t\t\tS4 = bsize;\n\t\t\t\tj4 -= bsize;\n\t\t\t}\n\t\t\tdx5 = sx[5] - ( S4*sx[4] );\n\t\t\tdy5 = sy[5] - ( S4*sy[4] );\n\t\t\tox4 = ox5 + ( j4*sx[4] );\n\t\t\toy4 = oy5 + ( j4*sy[4] );\n\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\tS3 = j3;\n\t\t\t\t\tj3 = 0;\n\t\t\t\t} else {\n\t\t\t\t\tS3 = bsize;\n\t\t\t\t\tj3 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx4 = sx[4] - ( S3*sx[3] );\n\t\t\t\tdy4 = sy[4] - ( S3*sy[3] );\n\t\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\t\toy3 = oy4 + ( j3*sy[3] );\n\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\tS2 = j2;\n\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tS2 = bsize;\n\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx3 = sx[3] - ( S2*sx[2] );\n\t\t\t\t\tdy3 = sy[3] - ( S2*sy[2] );\n\t\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\t\toy2 = oy3 + ( j2*sy[2] );\n\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\tS1 = j1;\n\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tS1 = bsize;\n\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdx2 = sx[2] - ( S1*sx[1] );\n\t\t\t\t\t\tdy2 = sy[2] - ( S1*sy[1] );\n\t\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\t\toy1 = oy2 + ( j1*sy[1] );\n\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\tS0 = j0;\n\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tS0 = bsize;\n\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Compute index offsets for the first input and output ndarray elements in the current block...\n\t\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\t\t\t\t\t\t\tiy = oy1 + ( j0*sy[0] );\n\n\t\t\t\t\t\t\t// Compute loop offset increments...\n\t\t\t\t\t\t\tdx1 = sx[1] - ( S0*sx[0] );\n\t\t\t\t\t\t\tdy1 = sy[1] - ( S0*sy[0] );\n\n\t\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tybuf[ iy ] = fcn.call( thisArg, xbuf[ ix ], take( [ i5, i4, i3, i2, i1, i0 ], idx ), x.ref );\n\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\t\t\tiy += dy2;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\t\t\tiy += dy3;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\t\t\tiy += dy4;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t\t\t\tiy += dy5;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedmap6d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\nimport take from '@stdlib/array-base-take-indexed';\nimport reverse from '@stdlib/array-base-reverse';\n\n\n// MAIN //\n\n/**\n* Applies a callback function to elements in a seven-dimensional input ndarray and assigns results to elements in an equivalently shaped output ndarray via loop blocking.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {string} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback execution context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* function scale( z ) {\n*     return z * 10.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( 6 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 4, 4, 1 ];\n* var sy = [ 6, 6, 6, 6, 2, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 1;\n* var oy = 0;\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Apply the map function:\n* blockedmap7d( x, y, scale, {} );\n*\n* console.log( y.data );\n* // => <Float64Array>[ 20.0, 30.0, 60.0, 70.0, 100.0, 110.0 ]\n*/\nfunction blockedmap7d( x, y, fcn, thisArg ) { // eslint-disable-line max-statements\n\tvar bsize;\n\tvar xbuf;\n\tvar ybuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar dy5;\n\tvar dy6;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar ox5;\n\tvar ox6;\n\tvar oy1;\n\tvar oy2;\n\tvar oy3;\n\tvar oy4;\n\tvar oy5;\n\tvar oy6;\n\tvar idx;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar sx;\n\tvar sy;\n\tvar ox;\n\tvar oy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides, y.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tsy = o.sy;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Cache the indices of the first indexed elements in the respective ndarrays...\n\tox = x.offset;\n\toy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache offset increments for the innermost loop...\n\tdx0 = sx[0];\n\tdy0 = sy[0];\n\n\t// Iterate over blocks...\n\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\tif ( j6 < bsize ) {\n\t\t\tS6 = j6;\n\t\t\tj6 = 0;\n\t\t} else {\n\t\t\tS6 = bsize;\n\t\t\tj6 -= bsize;\n\t\t}\n\t\tox6 = ox + ( j6*sx[6] );\n\t\toy6 = oy + ( j6*sy[6] );\n\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\tif ( j5 < bsize ) {\n\t\t\t\tS5 = j5;\n\t\t\t\tj5 = 0;\n\t\t\t} else {\n\t\t\t\tS5 = bsize;\n\t\t\t\tj5 -= bsize;\n\t\t\t}\n\t\t\tdx6 = sx[6] - ( S5*sx[5] );\n\t\t\tdy6 = sy[6] - ( S5*sy[5] );\n\t\t\tox5 = ox6 + ( j5*sx[5] );\n\t\t\toy5 = oy6 + ( j5*sy[5] );\n\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\tS4 = j4;\n\t\t\t\t\tj4 = 0;\n\t\t\t\t} else {\n\t\t\t\t\tS4 = bsize;\n\t\t\t\t\tj4 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx5 = sx[5] - ( S4*sx[4] );\n\t\t\t\tdy5 = sy[5] - ( S4*sy[4] );\n\t\t\t\tox4 = ox5 + ( j4*sx[4] );\n\t\t\t\toy4 = oy5 + ( j4*sy[4] );\n\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\tS3 = j3;\n\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tS3 = bsize;\n\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx4 = sx[4] - ( S3*sx[3] );\n\t\t\t\t\tdy4 = sy[4] - ( S3*sy[3] );\n\t\t\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\t\t\toy3 = oy4 + ( j3*sy[3] );\n\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\tS2 = j2;\n\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tS2 = bsize;\n\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdx3 = sx[3] - ( S2*sx[2] );\n\t\t\t\t\t\tdy3 = sy[3] - ( S2*sy[2] );\n\t\t\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\t\t\toy2 = oy3 + ( j2*sy[2] );\n\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\tS1 = j1;\n\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tS1 = bsize;\n\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdx2 = sx[2] - ( S1*sx[1] );\n\t\t\t\t\t\t\tdy2 = sy[2] - ( S1*sy[1] );\n\t\t\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\t\t\toy1 = oy2 + ( j1*sy[1] );\n\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\tS0 = j0;\n\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tS0 = bsize;\n\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Compute index offsets for the first input and output ndarray elements in the current block...\n\t\t\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\t\t\t\t\t\t\t\tiy = oy1 + ( j0*sy[0] );\n\n\t\t\t\t\t\t\t\t// Compute loop offset increments...\n\t\t\t\t\t\t\t\tdx1 = sx[1] - ( S0*sx[0] );\n\t\t\t\t\t\t\t\tdy1 = sy[1] - ( S0*sy[0] );\n\n\t\t\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tybuf[ iy ] = fcn.call( thisArg, xbuf[ ix ], take( [ i6, i5, i4, i3, i2, i1, i0 ], idx ), x.ref );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy2;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\t\t\t\t\tiy += dy3;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\t\t\t\t\tiy += dy4;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t\t\t\t\t\tiy += dy5;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tix += dx6;\n\t\t\t\t\t\t\t\t\tiy += dy6;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedmap7d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\nimport take from '@stdlib/array-base-take-indexed';\nimport reverse from '@stdlib/array-base-reverse';\n\n\n// MAIN //\n\n/**\n* Applies a callback function to elements in an eight-dimensional input ndarray and assigns results to elements in an equivalently shaped output ndarray via loop blocking.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {string} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback execution context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* function scale( z ) {\n*     return z * 10.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( 6 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 4, 4, 1 ];\n* var sy = [ 6, 6, 6, 6, 6, 2, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 1;\n* var oy = 0;\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Apply the map function:\n* blockedmap8d( x, y, scale, {} );\n*\n* console.log( y.data );\n* // => <Float64Array>[ 20.0, 30.0, 60.0, 70.0, 100.0, 110.0 ]\n*/\nfunction blockedmap8d( x, y, fcn, thisArg ) { // eslint-disable-line max-statements, max-lines-per-function\n\tvar bsize;\n\tvar xbuf;\n\tvar ybuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar dy5;\n\tvar dy6;\n\tvar dy7;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar ox5;\n\tvar ox6;\n\tvar ox7;\n\tvar oy1;\n\tvar oy2;\n\tvar oy3;\n\tvar oy4;\n\tvar oy5;\n\tvar oy6;\n\tvar oy7;\n\tvar idx;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar S7;\n\tvar sx;\n\tvar sy;\n\tvar ox;\n\tvar oy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar j7;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides, y.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tsy = o.sy;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Cache the indices of the first indexed elements in the respective ndarrays...\n\tox = x.offset;\n\toy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache offset increments for the innermost loop...\n\tdx0 = sx[0];\n\tdy0 = sy[0];\n\n\t// Iterate over blocks...\n\tfor ( j7 = sh[7]; j7 > 0; ) {\n\t\tif ( j7 < bsize ) {\n\t\t\tS7 = j7;\n\t\t\tj7 = 0;\n\t\t} else {\n\t\t\tS7 = bsize;\n\t\t\tj7 -= bsize;\n\t\t}\n\t\tox7 = ox + ( j7*sx[7] );\n\t\toy7 = oy + ( j7*sy[7] );\n\t\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\t\tif ( j6 < bsize ) {\n\t\t\t\tS6 = j6;\n\t\t\t\tj6 = 0;\n\t\t\t} else {\n\t\t\t\tS6 = bsize;\n\t\t\t\tj6 -= bsize;\n\t\t\t}\n\t\t\tdx7 = sx[7] - ( S6*sx[6] );\n\t\t\tdy7 = sy[7] - ( S6*sy[6] );\n\t\t\tox6 = ox7 + ( j6*sx[6] );\n\t\t\toy6 = oy7 + ( j6*sy[6] );\n\t\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\t\tif ( j5 < bsize ) {\n\t\t\t\t\tS5 = j5;\n\t\t\t\t\tj5 = 0;\n\t\t\t\t} else {\n\t\t\t\t\tS5 = bsize;\n\t\t\t\t\tj5 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx6 = sx[6] - ( S5*sx[5] );\n\t\t\t\tdy6 = sy[6] - ( S5*sy[5] );\n\t\t\t\tox5 = ox6 + ( j5*sx[5] );\n\t\t\t\toy5 = oy6 + ( j5*sy[5] );\n\t\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\t\tS4 = j4;\n\t\t\t\t\t\tj4 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tS4 = bsize;\n\t\t\t\t\t\tj4 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx5 = sx[5] - ( S4*sx[4] );\n\t\t\t\t\tdy5 = sy[5] - ( S4*sy[4] );\n\t\t\t\t\tox4 = ox5 + ( j4*sx[4] );\n\t\t\t\t\toy4 = oy5 + ( j4*sy[4] );\n\t\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\t\tS3 = j3;\n\t\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tS3 = bsize;\n\t\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdx4 = sx[4] - ( S3*sx[3] );\n\t\t\t\t\t\tdy4 = sy[4] - ( S3*sy[3] );\n\t\t\t\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\t\t\t\toy3 = oy4 + ( j3*sy[3] );\n\t\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\t\tS2 = j2;\n\t\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tS2 = bsize;\n\t\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdx3 = sx[3] - ( S2*sx[2] );\n\t\t\t\t\t\t\tdy3 = sy[3] - ( S2*sy[2] );\n\t\t\t\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\t\t\t\toy2 = oy3 + ( j2*sy[2] );\n\t\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\t\tS1 = j1;\n\t\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tS1 = bsize;\n\t\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdx2 = sx[2] - ( S1*sx[1] );\n\t\t\t\t\t\t\t\tdy2 = sy[2] - ( S1*sy[1] );\n\t\t\t\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\t\t\t\toy1 = oy2 + ( j1*sy[1] );\n\t\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\t\tS0 = j0;\n\t\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tS0 = bsize;\n\t\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Compute index offsets for the first input and output ndarray elements in the current block...\n\t\t\t\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\t\t\t\t\t\t\t\t\tiy = oy1 + ( j0*sy[0] );\n\n\t\t\t\t\t\t\t\t\t// Compute loop offset increments...\n\t\t\t\t\t\t\t\t\tdx1 = sx[1] - ( S0*sx[0] );\n\t\t\t\t\t\t\t\t\tdy1 = sy[1] - ( S0*sy[0] );\n\n\t\t\t\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\t\t\t\tfor ( i7 = 0; i7 < S7; i7++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tybuf[ iy ] = fcn.call( thisArg, xbuf[ ix ], take( [ i7, i6, i5, i4, i3, i2, i1, i0 ], idx ), x.ref );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy2;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy3;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy4;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t\t\t\t\t\t\t\tiy += dy5;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tix += dx6;\n\t\t\t\t\t\t\t\t\t\t\tiy += dy6;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tix += dx7;\n\t\t\t\t\t\t\t\t\t\tiy += dy7;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedmap8d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\nimport take from '@stdlib/array-base-take-indexed';\nimport reverse from '@stdlib/array-base-reverse';\n\n\n// MAIN //\n\n/**\n* Applies a callback function to elements in a nine-dimensional input ndarray and assigns results to elements in an equivalently shaped output ndarray via loop blocking.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {string} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback execution context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* function scale( z ) {\n*     return z * 10.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( 6 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 1, 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 4, 4, 1 ];\n* var sy = [ 6, 6, 6, 6, 6, 6, 2, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 1;\n* var oy = 0;\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Apply the map function:\n* blockedmap9d( x, y, scale, {} );\n*\n* console.log( y.data );\n* // => <Float64Array>[ 20.0, 30.0, 60.0, 70.0, 100.0, 110.0 ]\n*/\nfunction blockedmap9d( x, y, fcn, thisArg ) { // eslint-disable-line max-statements, max-lines-per-function\n\tvar bsize;\n\tvar xbuf;\n\tvar ybuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar dx8;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar dy5;\n\tvar dy6;\n\tvar dy7;\n\tvar dy8;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar ox5;\n\tvar ox6;\n\tvar ox7;\n\tvar ox8;\n\tvar oy1;\n\tvar oy2;\n\tvar oy3;\n\tvar oy4;\n\tvar oy5;\n\tvar oy6;\n\tvar oy7;\n\tvar oy8;\n\tvar idx;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar S7;\n\tvar S8;\n\tvar sx;\n\tvar sy;\n\tvar ox;\n\tvar oy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar j7;\n\tvar j8;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides, y.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tsy = o.sy;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Cache the indices of the first indexed elements in the respective ndarrays...\n\tox = x.offset;\n\toy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache offset increments for the innermost loop...\n\tdx0 = sx[0];\n\tdy0 = sy[0];\n\n\t// Iterate over blocks...\n\tfor ( j8 = sh[8]; j8 > 0; ) {\n\t\tif ( j8 < bsize ) {\n\t\t\tS8 = j8;\n\t\t\tj8 = 0;\n\t\t} else {\n\t\t\tS8 = bsize;\n\t\t\tj8 -= bsize;\n\t\t}\n\t\tox8 = ox + ( j8*sx[8] );\n\t\toy8 = oy + ( j8*sy[8] );\n\t\tfor ( j7 = sh[7]; j7 > 0; ) {\n\t\t\tif ( j7 < bsize ) {\n\t\t\t\tS7 = j7;\n\t\t\t\tj7 = 0;\n\t\t\t} else {\n\t\t\t\tS7 = bsize;\n\t\t\t\tj7 -= bsize;\n\t\t\t}\n\t\t\tdx8 = sx[8] - ( S7*sx[7] );\n\t\t\tdy8 = sy[8] - ( S7*sy[7] );\n\t\t\tox7 = ox8 + ( j7*sx[7] );\n\t\t\toy7 = oy8 + ( j7*sy[7] );\n\t\t\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\t\t\tif ( j6 < bsize ) {\n\t\t\t\t\tS6 = j6;\n\t\t\t\t\tj6 = 0;\n\t\t\t\t} else {\n\t\t\t\t\tS6 = bsize;\n\t\t\t\t\tj6 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx7 = sx[7] - ( S6*sx[6] );\n\t\t\t\tdy7 = sy[7] - ( S6*sy[6] );\n\t\t\t\tox6 = ox7 + ( j6*sx[6] );\n\t\t\t\toy6 = oy7 + ( j6*sy[6] );\n\t\t\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\t\t\tif ( j5 < bsize ) {\n\t\t\t\t\t\tS5 = j5;\n\t\t\t\t\t\tj5 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tS5 = bsize;\n\t\t\t\t\t\tj5 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx6 = sx[6] - ( S5*sx[5] );\n\t\t\t\t\tdy6 = sy[6] - ( S5*sy[5] );\n\t\t\t\t\tox5 = ox6 + ( j5*sx[5] );\n\t\t\t\t\toy5 = oy6 + ( j5*sy[5] );\n\t\t\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\t\t\tS4 = j4;\n\t\t\t\t\t\t\tj4 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tS4 = bsize;\n\t\t\t\t\t\t\tj4 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdx5 = sx[5] - ( S4*sx[4] );\n\t\t\t\t\t\tdy5 = sy[5] - ( S4*sy[4] );\n\t\t\t\t\t\tox4 = ox5 + ( j4*sx[4] );\n\t\t\t\t\t\toy4 = oy5 + ( j4*sy[4] );\n\t\t\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\t\t\tS3 = j3;\n\t\t\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tS3 = bsize;\n\t\t\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdx4 = sx[4] - ( S3*sx[3] );\n\t\t\t\t\t\t\tdy4 = sy[4] - ( S3*sy[3] );\n\t\t\t\t\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\t\t\t\t\toy3 = oy4 + ( j3*sy[3] );\n\t\t\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\t\t\tS2 = j2;\n\t\t\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tS2 = bsize;\n\t\t\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdx3 = sx[3] - ( S2*sx[2] );\n\t\t\t\t\t\t\t\tdy3 = sy[3] - ( S2*sy[2] );\n\t\t\t\t\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\t\t\t\t\toy2 = oy3 + ( j2*sy[2] );\n\t\t\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\t\t\tS1 = j1;\n\t\t\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tS1 = bsize;\n\t\t\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tdx2 = sx[2] - ( S1*sx[1] );\n\t\t\t\t\t\t\t\t\tdy2 = sy[2] - ( S1*sy[1] );\n\t\t\t\t\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\t\t\t\t\toy1 = oy2 + ( j1*sy[1] );\n\t\t\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\t\t\tS0 = j0;\n\t\t\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tS0 = bsize;\n\t\t\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t// Compute index offsets for the first input and output ndarray elements in the current block...\n\t\t\t\t\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\t\t\t\t\t\t\t\t\t\tiy = oy1 + ( j0*sy[0] );\n\n\t\t\t\t\t\t\t\t\t\t// Compute loop offset increments...\n\t\t\t\t\t\t\t\t\t\tdx1 = sx[1] - ( S0*sx[0] );\n\t\t\t\t\t\t\t\t\t\tdy1 = sy[1] - ( S0*sy[0] );\n\n\t\t\t\t\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\t\t\t\t\tfor ( i8 = 0; i8 < S8; i8++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i7 = 0; i7 < S7; i7++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tybuf[ iy ] = fcn.call( thisArg, xbuf[ ix ], take( [ i8, i7, i6, i5, i4, i3, i2, i1, i0 ], idx ), x.ref );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy2;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy3;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy4;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx6;\n\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy6;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tix += dx7;\n\t\t\t\t\t\t\t\t\t\t\t\tiy += dy7;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tix += dx8;\n\t\t\t\t\t\t\t\t\t\t\tiy += dy8;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedmap9d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\nimport take from '@stdlib/array-base-take-indexed';\nimport reverse from '@stdlib/array-base-reverse';\n\n\n// MAIN //\n\n/**\n* Applies a callback function to elements in a ten-dimensional input ndarray and assigns results to elements in an equivalently shaped output ndarray via loop blocking.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {string} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback execution context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* function scale( z ) {\n*     return z * 10.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( 6 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 1, 1, 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 12, 4, 4, 1 ];\n* var sy = [ 6, 6, 6, 6, 6, 6, 6, 2, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 1;\n* var oy = 0;\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Apply the map function:\n* blockedmap10d( x, y, scale, {} );\n*\n* console.log( y.data );\n* // => <Float64Array>[ 20.0, 30.0, 60.0, 70.0, 100.0, 110.0 ]\n*/\nfunction blockedmap10d( x, y, fcn, thisArg ) { // eslint-disable-line max-statements, max-lines-per-function\n\tvar bsize;\n\tvar xbuf;\n\tvar ybuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar dx8;\n\tvar dx9;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar dy5;\n\tvar dy6;\n\tvar dy7;\n\tvar dy8;\n\tvar dy9;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar ox5;\n\tvar ox6;\n\tvar ox7;\n\tvar ox8;\n\tvar ox9;\n\tvar oy1;\n\tvar oy2;\n\tvar oy3;\n\tvar oy4;\n\tvar oy5;\n\tvar oy6;\n\tvar oy7;\n\tvar oy8;\n\tvar oy9;\n\tvar idx;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar S7;\n\tvar S8;\n\tvar S9;\n\tvar sx;\n\tvar sy;\n\tvar ox;\n\tvar oy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\tvar i9;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar j7;\n\tvar j8;\n\tvar j9;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides, y.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tsy = o.sy;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Cache the indices of the first indexed elements in the respective ndarrays...\n\tox = x.offset;\n\toy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache offset increments for the innermost loop...\n\tdx0 = sx[0];\n\tdy0 = sy[0];\n\n\t// Iterate over blocks...\n\tfor ( j9 = sh[9]; j9 > 0; ) {\n\t\tif ( j9 < bsize ) {\n\t\t\tS9 = j9;\n\t\t\tj9 = 0;\n\t\t} else {\n\t\t\tS9 = bsize;\n\t\t\tj9 -= bsize;\n\t\t}\n\t\tox9 = ox + ( j9*sx[9] );\n\t\toy9 = oy + ( j9*sy[9] );\n\t\tfor ( j8 = sh[8]; j8 > 0; ) {\n\t\t\tif ( j8 < bsize ) {\n\t\t\t\tS8 = j8;\n\t\t\t\tj8 = 0;\n\t\t\t} else {\n\t\t\t\tS8 = bsize;\n\t\t\t\tj8 -= bsize;\n\t\t\t}\n\t\t\tdx9 = sx[9] - ( S8*sx[8] );\n\t\t\tdy9 = sy[9] - ( S8*sy[8] );\n\t\t\tox8 = ox9 + ( j8*sx[8] );\n\t\t\toy8 = oy9 + ( j8*sy[8] );\n\t\t\tfor ( j7 = sh[7]; j7 > 0; ) {\n\t\t\t\tif ( j7 < bsize ) {\n\t\t\t\t\tS7 = j7;\n\t\t\t\t\tj7 = 0;\n\t\t\t\t} else {\n\t\t\t\t\tS7 = bsize;\n\t\t\t\t\tj7 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx8 = sx[8] - ( S7*sx[7] );\n\t\t\t\tdy8 = sy[8] - ( S7*sy[7] );\n\t\t\t\tox7 = ox8 + ( j7*sx[7] );\n\t\t\t\toy7 = oy8 + ( j7*sy[7] );\n\t\t\t\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\t\t\t\tif ( j6 < bsize ) {\n\t\t\t\t\t\tS6 = j6;\n\t\t\t\t\t\tj6 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tS6 = bsize;\n\t\t\t\t\t\tj6 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx7 = sx[7] - ( S6*sx[6] );\n\t\t\t\t\tdy7 = sy[7] - ( S6*sy[6] );\n\t\t\t\t\tox6 = ox7 + ( j6*sx[6] );\n\t\t\t\t\toy6 = oy7 + ( j6*sy[6] );\n\t\t\t\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\t\t\t\tif ( j5 < bsize ) {\n\t\t\t\t\t\t\tS5 = j5;\n\t\t\t\t\t\t\tj5 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tS5 = bsize;\n\t\t\t\t\t\t\tj5 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdx6 = sx[6] - ( S5*sx[5] );\n\t\t\t\t\t\tdy6 = sy[6] - ( S5*sy[5] );\n\t\t\t\t\t\tox5 = ox6 + ( j5*sx[5] );\n\t\t\t\t\t\toy5 = oy6 + ( j5*sy[5] );\n\t\t\t\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\t\t\t\tS4 = j4;\n\t\t\t\t\t\t\t\tj4 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tS4 = bsize;\n\t\t\t\t\t\t\t\tj4 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdx5 = sx[5] - ( S4*sx[4] );\n\t\t\t\t\t\t\tdy5 = sy[5] - ( S4*sy[4] );\n\t\t\t\t\t\t\tox4 = ox5 + ( j4*sx[4] );\n\t\t\t\t\t\t\toy4 = oy5 + ( j4*sy[4] );\n\t\t\t\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\t\t\t\tS3 = j3;\n\t\t\t\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tS3 = bsize;\n\t\t\t\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdx4 = sx[4] - ( S3*sx[3] );\n\t\t\t\t\t\t\t\tdy4 = sy[4] - ( S3*sy[3] );\n\t\t\t\t\t\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\t\t\t\t\t\toy3 = oy4 + ( j3*sy[3] );\n\t\t\t\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\t\t\t\tS2 = j2;\n\t\t\t\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tS2 = bsize;\n\t\t\t\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tdx3 = sx[3] - ( S2*sx[2] );\n\t\t\t\t\t\t\t\t\tdy3 = sy[3] - ( S2*sy[2] );\n\t\t\t\t\t\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\t\t\t\t\t\toy2 = oy3 + ( j2*sy[2] );\n\t\t\t\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\t\t\t\tS1 = j1;\n\t\t\t\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tS1 = bsize;\n\t\t\t\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tdx2 = sx[2] - ( S1*sx[1] );\n\t\t\t\t\t\t\t\t\t\tdy2 = sy[2] - ( S1*sy[1] );\n\t\t\t\t\t\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\t\t\t\t\t\toy1 = oy2 + ( j1*sy[1] );\n\t\t\t\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\t\t\t\tS0 = j0;\n\t\t\t\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tS0 = bsize;\n\t\t\t\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t// Compute index offsets for the first input and output ndarray elements in the current block...\n\t\t\t\t\t\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\t\t\t\t\t\t\t\t\t\t\tiy = oy1 + ( j0*sy[0] );\n\n\t\t\t\t\t\t\t\t\t\t\t// Compute loop offset increments...\n\t\t\t\t\t\t\t\t\t\t\tdx1 = sx[1] - ( S0*sx[0] );\n\t\t\t\t\t\t\t\t\t\t\tdy1 = sy[1] - ( S0*sy[0] );\n\n\t\t\t\t\t\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\t\t\t\t\t\tfor ( i9 = 0; i9 < S9; i9++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i8 = 0; i8 < S8; i8++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i7 = 0; i7 < S7; i7++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tybuf[ iy ] = fcn.call( thisArg, xbuf[ ix ], take( [ i9, i8, i7, i6, i5, i4, i3, i2, i1, i0 ], idx ), x.ref );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy2;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy3;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy4;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx6;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy6;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx7;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy7;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx8;\n\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy8;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tix += dx9;\n\t\t\t\t\t\t\t\t\t\t\t\tiy += dy9;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedmap10d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\nimport take from '@stdlib/array-base-take-indexed';\nimport reverse from '@stdlib/array-base-reverse';\n\n\n// MAIN //\n\n/**\n* Applies a callback function to elements in a two-dimensional input ndarray and assigns results to elements in an equivalently shaped output ndarray via loop blocking.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {string} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback execution context\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import Complex64 from '@stdlib/complex-float32-ctor';\n* import realf from '@stdlib/complex-float32-real';\n* import imagf from '@stdlib/complex-float32-imag';\n*\n* function scale( z ) {\n*     return new Complex64( realf(z)*10.0, imagf(z)*10.0 );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Complex64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 2, 1 ];\n* var sy = [ 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'ref': null,\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n* var y = {\n*     'dtype': 'complex64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Apply the map function:\n* blockedmap2d( x, y, scale, {} );\n*\n* var v = y.data.get( 0 );\n*\n* var re = realf( v );\n* // returns 10.0\n*\n* var im = imagf( v );\n* // returns 20.0\n*/\nfunction blockedmap2d( x, y, fcn, thisArg ) {\n\tvar bsize;\n\tvar xbuf;\n\tvar ybuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dy0;\n\tvar dy1;\n\tvar ox1;\n\tvar oy1;\n\tvar idx;\n\tvar get;\n\tvar set;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar sx;\n\tvar sy;\n\tvar ox;\n\tvar oy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar j0;\n\tvar j1;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides, y.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tsy = o.sy;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Cache the indices of the first indexed elements in the respective ndarrays...\n\tox = x.offset;\n\toy = y.offset;\n\n\t// Cache the references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache offset increments for the innermost loop...\n\tdx0 = sx[0];\n\tdy0 = sy[0];\n\n\t// Iterate over blocks...\n\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\tif ( j1 < bsize ) {\n\t\t\ts1 = j1;\n\t\t\tj1 = 0;\n\t\t} else {\n\t\t\ts1 = bsize;\n\t\t\tj1 -= bsize;\n\t\t}\n\t\tox1 = ox + ( j1*sx[1] );\n\t\toy1 = oy + ( j1*sy[1] );\n\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\tif ( j0 < bsize ) {\n\t\t\t\ts0 = j0;\n\t\t\t\tj0 = 0;\n\t\t\t} else {\n\t\t\t\ts0 = bsize;\n\t\t\t\tj0 -= bsize;\n\t\t\t}\n\t\t\t// Compute the index offsets for the first input and output ndarray elements in the current block...\n\t\t\tix = ox1 + (j0*sx[0]);\n\t\t\tiy = oy1 + (j0*sy[0]);\n\n\t\t\t// Compute the loop offset increments...\n\t\t\tdx1 = sx[1] - (s0*sx[0]);\n\t\t\tdy1 = sy[1] - (s0*sy[0]);\n\n\t\t\t// Cache accessors:\n\t\t\tget = x.accessors[0];\n\t\t\tset = y.accessors[1];\n\n\t\t\t// Iterate over the ndarray dimensions...\n\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\tset( ybuf, iy, fcn.call( thisArg, get( xbuf, ix ), take( [ i1, i0 ], idx ), x.ref ) ); // eslint-disable-line max-len\n\t\t\t\t\tix += dx0;\n\t\t\t\t\tiy += dy0;\n\t\t\t\t}\n\t\t\t\tix += dx1;\n\t\t\t\tiy += dy1;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedmap2d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\nimport take from '@stdlib/array-base-take-indexed';\nimport reverse from '@stdlib/array-base-reverse';\n\n\n// MAIN //\n\n/**\n* Applies a callback function to elements in a three-dimensional input ndarray and assigns results to elements in an equivalently shaped output ndarray via loop blocking.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {string} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback execution context\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import Complex64 from '@stdlib/complex-float32-ctor';\n* import realf from '@stdlib/complex-float32-real';\n* import imagf from '@stdlib/complex-float32-imag';\n*\n* function scale( z ) {\n*     return new Complex64( realf(z)*10.0, imagf(z)*10.0 );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Complex64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 2, 2, 1 ];\n* var sy = [ 2, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'ref': null,\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n* var y = {\n*     'dtype': 'complex64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Apply the map function:\n* blockedmap3d( x, y, scale, {} );\n*\n* var v = y.data.get( 0 );\n*\n* var re = realf( v );\n* // returns 10.0\n*\n* var im = imagf( v );\n* // returns 20.0\n*/\nfunction blockedmap3d( x, y, fcn, thisArg ) {\n\tvar bsize;\n\tvar xbuf;\n\tvar ybuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar ox1;\n\tvar ox2;\n\tvar oy1;\n\tvar oy2;\n\tvar idx;\n\tvar get;\n\tvar set;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar sx;\n\tvar sy;\n\tvar ox;\n\tvar oy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides, y.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tsy = o.sy;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Cache the indices of the first indexed elements in the respective ndarrays...\n\tox = x.offset;\n\toy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache offset increments for the innermost loop...\n\tdx0 = sx[0];\n\tdy0 = sy[0];\n\n\t// Cache accessors:\n\tget = x.accessors[0];\n\tset = y.accessors[1];\n\n\t// Iterate over blocks...\n\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\tif ( j2 < bsize ) {\n\t\t\ts2 = j2;\n\t\t\tj2 = 0;\n\t\t} else {\n\t\t\ts2 = bsize;\n\t\t\tj2 -= bsize;\n\t\t}\n\t\tox2 = ox + ( j2*sx[2] );\n\t\toy2 = oy + ( j2*sy[2] );\n\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\tif ( j1 < bsize ) {\n\t\t\t\ts1 = j1;\n\t\t\t\tj1 = 0;\n\t\t\t} else {\n\t\t\t\ts1 = bsize;\n\t\t\t\tj1 -= bsize;\n\t\t\t}\n\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\tdy2 = sy[2] - ( s1*sy[1] );\n\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\toy1 = oy2 + ( j1*sy[1] );\n\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\ts0 = j0;\n\t\t\t\t\tj0 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts0 = bsize;\n\t\t\t\t\tj0 -= bsize;\n\t\t\t\t}\n\t\t\t\t// Compute index offsets for the first input and output ndarray elements in the current block...\n\t\t\t\tix = ox1 + ( j0*sx[0] );\n\t\t\t\tiy = oy1 + ( j0*sy[0] );\n\n\t\t\t\t// Compute loop offset increments...\n\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\t\t\t\tdy1 = sy[1] - ( s0*sy[0] );\n\n\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\tset( ybuf, iy, fcn.call( thisArg, get( xbuf, ix ), take( [ i2, i1, i0 ], idx ), x.ref ) ); // eslint-disable-line max-len\n\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx2;\n\t\t\t\t\tiy += dy2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedmap3d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\nimport take from '@stdlib/array-base-take-indexed';\nimport reverse from '@stdlib/array-base-reverse';\n\n\n// MAIN //\n\n/**\n* Applies a callback function to elements in a four-dimensional input ndarray and assigns results to elements in an equivalently shaped output ndarray via loop blocking.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {string} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback execution context\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import Complex64 from '@stdlib/complex-float32-ctor';\n* import realf from '@stdlib/complex-float32-real';\n* import imagf from '@stdlib/complex-float32-imag';\n*\n* function scale( z ) {\n*     return new Complex64( realf(z)*10.0, imagf(z)*10.0 );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Complex64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 2, 1 ];\n* var sy = [ 4, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'ref': null,\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n* var y = {\n*     'dtype': 'complex64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Apply the map function:\n* blockedmap4d( x, y, scale, {} );\n*\n* var v = y.data.get( 0 );\n*\n* var re = realf( v );\n* // returns 10.0\n*\n* var im = imagf( v );\n* // returns 20.0\n*/\nfunction blockedmap4d( x, y, fcn, thisArg ) { // eslint-disable-line max-statements\n\tvar bsize;\n\tvar xbuf;\n\tvar ybuf;\n\tvar get;\n\tvar set;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar idx;\n\tvar oy1;\n\tvar oy2;\n\tvar oy3;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar sx;\n\tvar sy;\n\tvar ox;\n\tvar oy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides, y.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tsy = o.sy;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Cache the indices of the first indexed elements in the respective ndarrays...\n\tox = x.offset;\n\toy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache offset increments for the innermost loop...\n\tdx0 = sx[0];\n\tdy0 = sy[0];\n\n\t// Iterate over blocks...\n\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\tif ( j3 < bsize ) {\n\t\t\tS3 = j3;\n\t\t\tj3 = 0;\n\t\t} else {\n\t\t\tS3 = bsize;\n\t\t\tj3 -= bsize;\n\t\t}\n\t\tox3 = ox + ( j3*sx[3] );\n\t\toy3 = oy + ( j3*sy[3] );\n\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\tif ( j2 < bsize ) {\n\t\t\t\tS2 = j2;\n\t\t\t\tj2 = 0;\n\t\t\t} else {\n\t\t\t\tS2 = bsize;\n\t\t\t\tj2 -= bsize;\n\t\t\t}\n\t\t\tdx3 = sx[3] - ( S2*sx[2] );\n\t\t\tdy3 = sy[3] - ( S2*sy[2] );\n\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\toy2 = oy3 + ( j2*sy[2] );\n\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\tS1 = j1;\n\t\t\t\t\tj1 = 0;\n\t\t\t\t} else {\n\t\t\t\t\tS1 = bsize;\n\t\t\t\t\tj1 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx2 = sx[2] - ( S1*sx[1] );\n\t\t\t\tdy2 = sy[2] - ( S1*sy[1] );\n\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\toy1 = oy2 + ( j1*sy[1] );\n\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\tS0 = j0;\n\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tS0 = bsize;\n\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\t// Compute index offsets for the first input and output ndarray elements in the current block...\n\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\t\t\t\t\tiy = oy1 + ( j0*sy[0] );\n\n\t\t\t\t\t// Compute loop offset increments...\n\t\t\t\t\tdx1 = sx[1] - ( S0*sx[0] );\n\t\t\t\t\tdy1 = sy[1] - ( S0*sy[0] );\n\n\t\t\t\t\t// Cache accessors:\n\t\t\t\t\tget = x.accessors[ 0 ];\n\t\t\t\t\tset = y.accessors[ 1 ];\n\n\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\tset( ybuf, iy, fcn.call( thisArg, get( xbuf, ix ), take( [ i3, i2, i1, i0 ], idx ), x.ref ) ); // eslint-disable-line max-len\n\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\tiy += dy2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\tiy += dy3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedmap4d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\nimport take from '@stdlib/array-base-take-indexed';\nimport reverse from '@stdlib/array-base-reverse';\n\n\n// MAIN //\n\n/**\n* Applies a callback function to elements in a five-dimensional input ndarray and assigns results to elements in an equivalently shaped output ndarray via loop blocking.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {string} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback execution context\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import Complex64 from '@stdlib/complex-float32-ctor';\n* import realf from '@stdlib/complex-float32-real';\n* import imagf from '@stdlib/complex-float32-imag';\n*\n* function scale( z ) {\n*     return new Complex64( realf(z)*10.0, imagf(z)*10.0 );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Complex64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 4, 2, 1 ];\n* var sy = [ 4, 4, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'ref': null,\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n* var y = {\n*     'dtype': 'complex64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Apply the map function:\n* blockedmap5d( x, y, scale, {} );\n*\n* var v = y.data.get( 0 );\n*\n* var re = realf( v );\n* // returns 10.0\n*\n* var im = imagf( v );\n* // returns 20.0\n*/\nfunction blockedmap5d( x, y, fcn, thisArg ) { // eslint-disable-line max-statements\n\tvar bsize;\n\tvar xbuf;\n\tvar ybuf;\n\tvar get;\n\tvar set;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar idx;\n\tvar oy1;\n\tvar oy2;\n\tvar oy3;\n\tvar oy4;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar sx;\n\tvar sy;\n\tvar ox;\n\tvar oy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides, y.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tsy = o.sy;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Cache the indices of the first indexed elements in the respective ndarrays...\n\tox = x.offset;\n\toy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache offset increments for the innermost loop...\n\tdx0 = sx[0];\n\tdy0 = sy[0];\n\n\t// Cache accessors:\n\tget = x.accessors[0];\n\tset = y.accessors[1];\n\n\t// Iterate over blocks...\n\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\tif ( j4 < bsize ) {\n\t\t\tS4 = j4;\n\t\t\tj4 = 0;\n\t\t} else {\n\t\t\tS4 = bsize;\n\t\t\tj4 -= bsize;\n\t\t}\n\t\tox4 = ox + ( j4*sx[4] );\n\t\toy4 = oy + ( j4*sy[4] );\n\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\tif ( j3 < bsize ) {\n\t\t\t\tS3 = j3;\n\t\t\t\tj3 = 0;\n\t\t\t} else {\n\t\t\t\tS3 = bsize;\n\t\t\t\tj3 -= bsize;\n\t\t\t}\n\t\t\tdx4 = sx[4] - ( S3*sx[3] );\n\t\t\tdy4 = sy[4] - ( S3*sy[3] );\n\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\toy3 = oy4 + ( j3*sy[3] );\n\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\tS2 = j2;\n\t\t\t\t\tj2 = 0;\n\t\t\t\t} else {\n\t\t\t\t\tS2 = bsize;\n\t\t\t\t\tj2 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx3 = sx[3] - ( S2*sx[2] );\n\t\t\t\tdy3 = sy[3] - ( S2*sy[2] );\n\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\toy2 = oy3 + ( j2*sy[2] );\n\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\tS1 = j1;\n\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tS1 = bsize;\n\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx2 = sx[2] - ( S1*sx[1] );\n\t\t\t\t\tdy2 = sy[2] - ( S1*sy[1] );\n\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\toy1 = oy2 + ( j1*sy[1] );\n\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\tS0 = j0;\n\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tS0 = bsize;\n\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Compute index offsets for the first input and output ndarray elements in the current block...\n\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\t\t\t\t\t\tiy = oy1 + ( j0*sy[0] );\n\n\t\t\t\t\t\t// Compute loop offset increments...\n\t\t\t\t\t\tdx1 = sx[1] - ( S0*sx[0] );\n\t\t\t\t\t\tdy1 = sy[1] - ( S0*sy[0] );\n\n\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\tset( ybuf, iy, fcn.call( thisArg, get( xbuf, ix ), take( [ i4, i3, i2, i1, i0 ], idx ), x.ref ) ); // eslint-disable-line max-len\n\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\tiy += dy2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\tiy += dy3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\tiy += dy4;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedmap5d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\nimport take from '@stdlib/array-base-take-indexed';\nimport reverse from '@stdlib/array-base-reverse';\n\n\n// MAIN //\n\n/**\n* Applies a callback function to elements in a six-dimensional input ndarray and assigns results to elements in an equivalently shaped output ndarray via loop blocking.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {string} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback execution context\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import Complex64 from '@stdlib/complex-float32-ctor';\n* import realf from '@stdlib/complex-float32-real';\n* import imagf from '@stdlib/complex-float32-imag';\n*\n* function scale( z ) {\n*     return new Complex64( realf(z)*10.0, imagf(z)*10.0 );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Complex64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 1, 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 4, 4, 2, 1 ];\n* var sy = [ 4, 4, 4, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'ref': null,\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n* var y = {\n*     'dtype': 'complex64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Apply the map function:\n* blockedmap6d( x, y, scale, {} );\n*\n* var v = y.data.get( 0 );\n*\n* var re = realf( v );\n* // returns 10.0\n*\n* var im = imagf( v );\n* // returns 20.0\n*/\nfunction blockedmap6d( x, y, fcn, thisArg ) { // eslint-disable-line max-statements\n\tvar bsize;\n\tvar xbuf;\n\tvar ybuf;\n\tvar set;\n\tvar get;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar dy5;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar ox5;\n\tvar oy1;\n\tvar oy2;\n\tvar oy3;\n\tvar oy4;\n\tvar oy5;\n\tvar idx;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar sx;\n\tvar sy;\n\tvar ox;\n\tvar oy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides, y.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tsy = o.sy;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Cache the indices of the first indexed elements in the respective ndarrays...\n\tox = x.offset;\n\toy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache offset increments for the innermost loop...\n\tdx0 = sx[0];\n\tdy0 = sy[0];\n\n\t// Cache accessors:\n\tget = x.accessors[0];\n\tset = y.accessors[1];\n\n\t// Iterate over blocks...\n\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\tif ( j5 < bsize ) {\n\t\t\tS5 = j5;\n\t\t\tj5 = 0;\n\t\t} else {\n\t\t\tS5 = bsize;\n\t\t\tj5 -= bsize;\n\t\t}\n\t\tox5 = ox + ( j5*sx[5] );\n\t\toy5 = oy + ( j5*sy[5] );\n\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\tif ( j4 < bsize ) {\n\t\t\t\tS4 = j4;\n\t\t\t\tj4 = 0;\n\t\t\t} else {\n\t\t\t\tS4 = bsize;\n\t\t\t\tj4 -= bsize;\n\t\t\t}\n\t\t\tdx5 = sx[5] - ( S4*sx[4] );\n\t\t\tdy5 = sy[5] - ( S4*sy[4] );\n\t\t\tox4 = ox5 + ( j4*sx[4] );\n\t\t\toy4 = oy5 + ( j4*sy[4] );\n\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\tS3 = j3;\n\t\t\t\t\tj3 = 0;\n\t\t\t\t} else {\n\t\t\t\t\tS3 = bsize;\n\t\t\t\t\tj3 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx4 = sx[4] - ( S3*sx[3] );\n\t\t\t\tdy4 = sy[4] - ( S3*sy[3] );\n\t\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\t\toy3 = oy4 + ( j3*sy[3] );\n\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\tS2 = j2;\n\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tS2 = bsize;\n\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx3 = sx[3] - ( S2*sx[2] );\n\t\t\t\t\tdy3 = sy[3] - ( S2*sy[2] );\n\t\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\t\toy2 = oy3 + ( j2*sy[2] );\n\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\tS1 = j1;\n\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tS1 = bsize;\n\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdx2 = sx[2] - ( S1*sx[1] );\n\t\t\t\t\t\tdy2 = sy[2] - ( S1*sy[1] );\n\t\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\t\toy1 = oy2 + ( j1*sy[1] );\n\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\tS0 = j0;\n\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tS0 = bsize;\n\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Compute index offsets for the first input and output ndarray elements in the current block...\n\t\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\t\t\t\t\t\t\tiy = oy1 + ( j0*sy[0] );\n\n\t\t\t\t\t\t\t// Compute loop offset increments...\n\t\t\t\t\t\t\tdx1 = sx[1] - ( S0*sx[0] );\n\t\t\t\t\t\t\tdy1 = sy[1] - ( S0*sy[0] );\n\n\t\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tset( ybuf, iy, fcn.call( thisArg, get( xbuf, ix ), take( [ i5, i4, i3, i2, i1, i0 ], idx ), x.ref ) );\n\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\t\t\tiy += dy2;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\t\t\tiy += dy3;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\t\t\tiy += dy4;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t\t\t\tiy += dy5;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedmap6d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\nimport take from '@stdlib/array-base-take-indexed';\nimport reverse from '@stdlib/array-base-reverse';\n\n\n// MAIN //\n\n/**\n* Applies a callback function to elements in a seven-dimensional input ndarray and assigns results to elements in an equivalently shaped output ndarray via loop blocking.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {string} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback execution context\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import Complex64 from '@stdlib/complex-float32-ctor';\n* import realf from '@stdlib/complex-float32-real';\n* import imagf from '@stdlib/complex-float32-imag';\n*\n* function scale( z ) {\n*     return new Complex64( realf(z)*10.0, imagf(z)*10.0 );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Complex64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 1, 1, 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 4, 4, 4, 2, 1 ];\n* var sy = [ 4, 4, 4, 4, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'ref': null,\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n* var y = {\n*     'dtype': 'complex64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Apply the map function:\n* blockedmap7d( x, y, scale, {} );\n*\n* var v = y.data.get( 0 );\n*\n* var re = realf( v );\n* // returns 10.0\n*\n* var im = imagf( v );\n* // returns 20.0\n*/\nfunction blockedmap7d( x, y, fcn, thisArg ) { // eslint-disable-line max-statements\n\tvar bsize;\n\tvar xbuf;\n\tvar ybuf;\n\tvar get;\n\tvar set;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar dy5;\n\tvar dy6;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar ox5;\n\tvar ox6;\n\tvar oy1;\n\tvar oy2;\n\tvar oy3;\n\tvar oy4;\n\tvar oy5;\n\tvar oy6;\n\tvar idx;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar sx;\n\tvar sy;\n\tvar ox;\n\tvar oy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides, y.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tsy = o.sy;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Cache the indices of the first indexed elements in the respective ndarrays...\n\tox = x.offset;\n\toy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache offset increments for the innermost loop...\n\tdx0 = sx[0];\n\tdy0 = sy[0];\n\n\t// Cache accessors:\n\tget = x.accessors[0];\n\tset = y.accessors[1];\n\n\t// Iterate over blocks...\n\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\tif ( j6 < bsize ) {\n\t\t\tS6 = j6;\n\t\t\tj6 = 0;\n\t\t} else {\n\t\t\tS6 = bsize;\n\t\t\tj6 -= bsize;\n\t\t}\n\t\tox6 = ox + ( j6*sx[6] );\n\t\toy6 = oy + ( j6*sy[6] );\n\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\tif ( j5 < bsize ) {\n\t\t\t\tS5 = j5;\n\t\t\t\tj5 = 0;\n\t\t\t} else {\n\t\t\t\tS5 = bsize;\n\t\t\t\tj5 -= bsize;\n\t\t\t}\n\t\t\tdx6 = sx[6] - ( S5*sx[5] );\n\t\t\tdy6 = sy[6] - ( S5*sy[5] );\n\t\t\tox5 = ox6 + ( j5*sx[5] );\n\t\t\toy5 = oy6 + ( j5*sy[5] );\n\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\tS4 = j4;\n\t\t\t\t\tj4 = 0;\n\t\t\t\t} else {\n\t\t\t\t\tS4 = bsize;\n\t\t\t\t\tj4 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx5 = sx[5] - ( S4*sx[4] );\n\t\t\t\tdy5 = sy[5] - ( S4*sy[4] );\n\t\t\t\tox4 = ox5 + ( j4*sx[4] );\n\t\t\t\toy4 = oy5 + ( j4*sy[4] );\n\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\tS3 = j3;\n\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tS3 = bsize;\n\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx4 = sx[4] - ( S3*sx[3] );\n\t\t\t\t\tdy4 = sy[4] - ( S3*sy[3] );\n\t\t\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\t\t\toy3 = oy4 + ( j3*sy[3] );\n\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\tS2 = j2;\n\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tS2 = bsize;\n\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdx3 = sx[3] - ( S2*sx[2] );\n\t\t\t\t\t\tdy3 = sy[3] - ( S2*sy[2] );\n\t\t\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\t\t\toy2 = oy3 + ( j2*sy[2] );\n\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\tS1 = j1;\n\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tS1 = bsize;\n\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdx2 = sx[2] - ( S1*sx[1] );\n\t\t\t\t\t\t\tdy2 = sy[2] - ( S1*sy[1] );\n\t\t\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\t\t\toy1 = oy2 + ( j1*sy[1] );\n\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\tS0 = j0;\n\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tS0 = bsize;\n\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Compute index offsets for the first input and output ndarray elements in the current block...\n\t\t\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\t\t\t\t\t\t\t\tiy = oy1 + ( j0*sy[0] );\n\n\t\t\t\t\t\t\t\t// Compute loop offset increments...\n\t\t\t\t\t\t\t\tdx1 = sx[1] - ( S0*sx[0] );\n\t\t\t\t\t\t\t\tdy1 = sy[1] - ( S0*sy[0] );\n\n\t\t\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tset( ybuf, iy, fcn.call( thisArg, get( xbuf, ix ), take( [ i6, i5, i4, i3, i2, i1, i0 ], idx ), x.ref ) );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy2;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\t\t\t\t\tiy += dy3;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\t\t\t\t\tiy += dy4;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t\t\t\t\t\tiy += dy5;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tix += dx6;\n\t\t\t\t\t\t\t\t\tiy += dy6;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedmap7d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\nimport take from '@stdlib/array-base-take-indexed';\nimport reverse from '@stdlib/array-base-reverse';\n\n\n// MAIN //\n\n/**\n* Applies a callback function to elements in an eight-dimensional input ndarray and assigns results to elements in an equivalently shaped output ndarray via loop blocking.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {string} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback execution context\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import Complex64 from '@stdlib/complex-float32-ctor';\n* import realf from '@stdlib/complex-float32-real';\n* import imagf from '@stdlib/complex-float32-imag';\n*\n* function scale( z ) {\n*     return new Complex64( realf(z)*10.0, imagf(z)*10.0 );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Complex64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 1, 1, 1, 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 4, 4, 4, 4, 2, 1 ];\n* var sy = [ 4, 4, 4, 4, 4, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'ref': null,\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n* var y = {\n*     'dtype': 'complex64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Apply the map function:\n* blockedmap8d( x, y, scale, {} );\n*\n* var v = y.data.get( 0 );\n*\n* var re = realf( v );\n* // returns 10.0\n*\n* var im = imagf( v );\n* // returns 20.0\n*/\nfunction blockedmap8d( x, y, fcn, thisArg ) { // eslint-disable-line max-statements, max-lines-per-function\n\tvar bsize;\n\tvar xbuf;\n\tvar ybuf;\n\tvar get;\n\tvar set;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar dy5;\n\tvar dy6;\n\tvar dy7;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar ox5;\n\tvar ox6;\n\tvar ox7;\n\tvar oy1;\n\tvar oy2;\n\tvar oy3;\n\tvar oy4;\n\tvar oy5;\n\tvar oy6;\n\tvar oy7;\n\tvar idx;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar S7;\n\tvar sx;\n\tvar sy;\n\tvar ox;\n\tvar oy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar j7;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides, y.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tsy = o.sy;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Cache the indices of the first indexed elements in the respective ndarrays...\n\tox = x.offset;\n\toy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache offset increments for the innermost loop...\n\tdx0 = sx[0];\n\tdy0 = sy[0];\n\n\t// Cache accessors:\n\tget = x.accessors[0];\n\tset = y.accessors[1];\n\n\t// Iterate over blocks...\n\tfor ( j7 = sh[7]; j7 > 0; ) {\n\t\tif ( j7 < bsize ) {\n\t\t\tS7 = j7;\n\t\t\tj7 = 0;\n\t\t} else {\n\t\t\tS7 = bsize;\n\t\t\tj7 -= bsize;\n\t\t}\n\t\tox7 = ox + ( j7*sx[7] );\n\t\toy7 = oy + ( j7*sy[7] );\n\t\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\t\tif ( j6 < bsize ) {\n\t\t\t\tS6 = j6;\n\t\t\t\tj6 = 0;\n\t\t\t} else {\n\t\t\t\tS6 = bsize;\n\t\t\t\tj6 -= bsize;\n\t\t\t}\n\t\t\tdx7 = sx[7] - ( S6*sx[6] );\n\t\t\tdy7 = sy[7] - ( S6*sy[6] );\n\t\t\tox6 = ox7 + ( j6*sx[6] );\n\t\t\toy6 = oy7 + ( j6*sy[6] );\n\t\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\t\tif ( j5 < bsize ) {\n\t\t\t\t\tS5 = j5;\n\t\t\t\t\tj5 = 0;\n\t\t\t\t} else {\n\t\t\t\t\tS5 = bsize;\n\t\t\t\t\tj5 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx6 = sx[6] - ( S5*sx[5] );\n\t\t\t\tdy6 = sy[6] - ( S5*sy[5] );\n\t\t\t\tox5 = ox6 + ( j5*sx[5] );\n\t\t\t\toy5 = oy6 + ( j5*sy[5] );\n\t\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\t\tS4 = j4;\n\t\t\t\t\t\tj4 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tS4 = bsize;\n\t\t\t\t\t\tj4 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx5 = sx[5] - ( S4*sx[4] );\n\t\t\t\t\tdy5 = sy[5] - ( S4*sy[4] );\n\t\t\t\t\tox4 = ox5 + ( j4*sx[4] );\n\t\t\t\t\toy4 = oy5 + ( j4*sy[4] );\n\t\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\t\tS3 = j3;\n\t\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tS3 = bsize;\n\t\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdx4 = sx[4] - ( S3*sx[3] );\n\t\t\t\t\t\tdy4 = sy[4] - ( S3*sy[3] );\n\t\t\t\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\t\t\t\toy3 = oy4 + ( j3*sy[3] );\n\t\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\t\tS2 = j2;\n\t\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tS2 = bsize;\n\t\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdx3 = sx[3] - ( S2*sx[2] );\n\t\t\t\t\t\t\tdy3 = sy[3] - ( S2*sy[2] );\n\t\t\t\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\t\t\t\toy2 = oy3 + ( j2*sy[2] );\n\t\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\t\tS1 = j1;\n\t\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tS1 = bsize;\n\t\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdx2 = sx[2] - ( S1*sx[1] );\n\t\t\t\t\t\t\t\tdy2 = sy[2] - ( S1*sy[1] );\n\t\t\t\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\t\t\t\toy1 = oy2 + ( j1*sy[1] );\n\t\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\t\tS0 = j0;\n\t\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tS0 = bsize;\n\t\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Compute index offsets for the first input and output ndarray elements in the current block...\n\t\t\t\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\t\t\t\t\t\t\t\t\tiy = oy1 + ( j0*sy[0] );\n\n\t\t\t\t\t\t\t\t\t// Compute loop offset increments...\n\t\t\t\t\t\t\t\t\tdx1 = sx[1] - ( S0*sx[0] );\n\t\t\t\t\t\t\t\t\tdy1 = sy[1] - ( S0*sy[0] );\n\n\t\t\t\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\t\t\t\tfor ( i7 = 0; i7 < S7; i7++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tset( ybuf, iy, fcn.call( thisArg, get( xbuf, ix ), take( [ i7, i6, i5, i4, i3, i2, i1, i0 ], idx ), x.ref ) );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy2;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy3;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy4;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t\t\t\t\t\t\t\tiy += dy5;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tix += dx6;\n\t\t\t\t\t\t\t\t\t\t\tiy += dy6;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tix += dx7;\n\t\t\t\t\t\t\t\t\t\tiy += dy7;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedmap8d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\nimport take from '@stdlib/array-base-take-indexed';\nimport reverse from '@stdlib/array-base-reverse';\n\n\n// MAIN //\n\n/**\n* Applies a callback function to elements in a nine-dimensional input ndarray and assigns results to elements in an equivalently shaped output ndarray via loop blocking.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {string} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback execution context\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import Complex64 from '@stdlib/complex-float32-ctor';\n* import realf from '@stdlib/complex-float32-real';\n* import imagf from '@stdlib/complex-float32-imag';\n*\n* function scale( z ) {\n*     return new Complex64( realf(z)*10.0, imagf(z)*10.0 );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Complex64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 1, 1, 1, 1, 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 4, 4, 4, 4, 4, 2, 1 ];\n* var sy = [ 4, 4, 4, 4, 4, 4, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'ref': null,\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n* var y = {\n*     'dtype': 'complex64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Apply the map function:\n* blockedmap9d( x, y, scale, {} );\n*\n* var v = y.data.get( 0 );\n*\n* var re = realf( v );\n* // returns 10.0\n*\n* var im = imagf( v );\n* // returns 20.0\n*/\nfunction blockedmap9d( x, y, fcn, thisArg ) { // eslint-disable-line max-statements, max-lines-per-function\n\tvar bsize;\n\tvar xbuf;\n\tvar ybuf;\n\tvar get;\n\tvar set;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar dx8;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar dy5;\n\tvar dy6;\n\tvar dy7;\n\tvar dy8;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar ox5;\n\tvar ox6;\n\tvar ox7;\n\tvar ox8;\n\tvar oy1;\n\tvar oy2;\n\tvar oy3;\n\tvar oy4;\n\tvar oy5;\n\tvar oy6;\n\tvar oy7;\n\tvar oy8;\n\tvar idx;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar S7;\n\tvar S8;\n\tvar sx;\n\tvar sy;\n\tvar ox;\n\tvar oy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar j7;\n\tvar j8;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides, y.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tsy = o.sy;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Cache the indices of the first indexed elements in the respective ndarrays...\n\tox = x.offset;\n\toy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache offset increments for the innermost loop...\n\tdx0 = sx[0];\n\tdy0 = sy[0];\n\n\t// Cache accessors:\n\tget = x.accessors[0];\n\tset = y.accessors[1];\n\n\t// Iterate over blocks...\n\tfor ( j8 = sh[8]; j8 > 0; ) {\n\t\tif ( j8 < bsize ) {\n\t\t\tS8 = j8;\n\t\t\tj8 = 0;\n\t\t} else {\n\t\t\tS8 = bsize;\n\t\t\tj8 -= bsize;\n\t\t}\n\t\tox8 = ox + ( j8*sx[8] );\n\t\toy8 = oy + ( j8*sy[8] );\n\t\tfor ( j7 = sh[7]; j7 > 0; ) {\n\t\t\tif ( j7 < bsize ) {\n\t\t\t\tS7 = j7;\n\t\t\t\tj7 = 0;\n\t\t\t} else {\n\t\t\t\tS7 = bsize;\n\t\t\t\tj7 -= bsize;\n\t\t\t}\n\t\t\tdx8 = sx[8] - ( S7*sx[7] );\n\t\t\tdy8 = sy[8] - ( S7*sy[7] );\n\t\t\tox7 = ox8 + ( j7*sx[7] );\n\t\t\toy7 = oy8 + ( j7*sy[7] );\n\t\t\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\t\t\tif ( j6 < bsize ) {\n\t\t\t\t\tS6 = j6;\n\t\t\t\t\tj6 = 0;\n\t\t\t\t} else {\n\t\t\t\t\tS6 = bsize;\n\t\t\t\t\tj6 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx7 = sx[7] - ( S6*sx[6] );\n\t\t\t\tdy7 = sy[7] - ( S6*sy[6] );\n\t\t\t\tox6 = ox7 + ( j6*sx[6] );\n\t\t\t\toy6 = oy7 + ( j6*sy[6] );\n\t\t\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\t\t\tif ( j5 < bsize ) {\n\t\t\t\t\t\tS5 = j5;\n\t\t\t\t\t\tj5 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tS5 = bsize;\n\t\t\t\t\t\tj5 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx6 = sx[6] - ( S5*sx[5] );\n\t\t\t\t\tdy6 = sy[6] - ( S5*sy[5] );\n\t\t\t\t\tox5 = ox6 + ( j5*sx[5] );\n\t\t\t\t\toy5 = oy6 + ( j5*sy[5] );\n\t\t\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\t\t\tS4 = j4;\n\t\t\t\t\t\t\tj4 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tS4 = bsize;\n\t\t\t\t\t\t\tj4 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdx5 = sx[5] - ( S4*sx[4] );\n\t\t\t\t\t\tdy5 = sy[5] - ( S4*sy[4] );\n\t\t\t\t\t\tox4 = ox5 + ( j4*sx[4] );\n\t\t\t\t\t\toy4 = oy5 + ( j4*sy[4] );\n\t\t\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\t\t\tS3 = j3;\n\t\t\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tS3 = bsize;\n\t\t\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdx4 = sx[4] - ( S3*sx[3] );\n\t\t\t\t\t\t\tdy4 = sy[4] - ( S3*sy[3] );\n\t\t\t\t\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\t\t\t\t\toy3 = oy4 + ( j3*sy[3] );\n\t\t\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\t\t\tS2 = j2;\n\t\t\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tS2 = bsize;\n\t\t\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdx3 = sx[3] - ( S2*sx[2] );\n\t\t\t\t\t\t\t\tdy3 = sy[3] - ( S2*sy[2] );\n\t\t\t\t\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\t\t\t\t\toy2 = oy3 + ( j2*sy[2] );\n\t\t\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\t\t\tS1 = j1;\n\t\t\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tS1 = bsize;\n\t\t\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tdx2 = sx[2] - ( S1*sx[1] );\n\t\t\t\t\t\t\t\t\tdy2 = sy[2] - ( S1*sy[1] );\n\t\t\t\t\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\t\t\t\t\toy1 = oy2 + ( j1*sy[1] );\n\t\t\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\t\t\tS0 = j0;\n\t\t\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tS0 = bsize;\n\t\t\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t// Compute index offsets for the first input and output ndarray elements in the current block...\n\t\t\t\t\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\t\t\t\t\t\t\t\t\t\tiy = oy1 + ( j0*sy[0] );\n\n\t\t\t\t\t\t\t\t\t\t// Compute loop offset increments...\n\t\t\t\t\t\t\t\t\t\tdx1 = sx[1] - ( S0*sx[0] );\n\t\t\t\t\t\t\t\t\t\tdy1 = sy[1] - ( S0*sy[0] );\n\n\t\t\t\t\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\t\t\t\t\tfor ( i8 = 0; i8 < S8; i8++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i7 = 0; i7 < S7; i7++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tset( ybuf, iy, fcn.call( thisArg, get( xbuf, ix ), take( [ i8, i7, i6, i5, i4, i3, i2, i1, i0 ], idx ), x.ref ) );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy2;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy3;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy4;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx6;\n\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy6;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tix += dx7;\n\t\t\t\t\t\t\t\t\t\t\t\tiy += dy7;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tix += dx8;\n\t\t\t\t\t\t\t\t\t\t\tiy += dy8;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedmap9d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\nimport take from '@stdlib/array-base-take-indexed';\nimport reverse from '@stdlib/array-base-reverse';\n\n\n// MAIN //\n\n/**\n* Applies a callback function to elements in a ten-dimensional input ndarray and assigns results to elements in an equivalently shaped output ndarray via loop blocking.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {string} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback execution context\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import Complex64 from '@stdlib/complex-float32-ctor';\n* import realf from '@stdlib/complex-float32-real';\n* import imagf from '@stdlib/complex-float32-imag';\n*\n* function scale( z ) {\n*     return new Complex64( realf(z)*10.0, imagf(z)*10.0 );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Complex64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 1, 1, 1, 1, 1, 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 4, 4, 4, 4, 4, 4, 2, 1 ];\n* var sy = [ 4, 4, 4, 4, 4, 4, 4, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'ref': null,\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n* var y = {\n*     'dtype': 'complex64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Apply the map function:\n* blockedmap10d( x, y, scale, {} );\n*\n* var v = y.data.get( 0 );\n*\n* var re = realf( v );\n* // returns 10.0\n*\n* var im = imagf( v );\n* // returns 20.0\n*/\nfunction blockedmap10d( x, y, fcn, thisArg ) { // eslint-disable-line max-statements, max-lines-per-function\n\tvar bsize;\n\tvar xbuf;\n\tvar ybuf;\n\tvar get;\n\tvar set;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar dx8;\n\tvar dx9;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar dy5;\n\tvar dy6;\n\tvar dy7;\n\tvar dy8;\n\tvar dy9;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar ox5;\n\tvar ox6;\n\tvar ox7;\n\tvar ox8;\n\tvar ox9;\n\tvar oy1;\n\tvar oy2;\n\tvar oy3;\n\tvar oy4;\n\tvar oy5;\n\tvar oy6;\n\tvar oy7;\n\tvar oy8;\n\tvar oy9;\n\tvar idx;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar S7;\n\tvar S8;\n\tvar S9;\n\tvar sx;\n\tvar sy;\n\tvar ox;\n\tvar oy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\tvar i9;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar j7;\n\tvar j8;\n\tvar j9;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides, y.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tsy = o.sy;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Cache the indices of the first indexed elements in the respective ndarrays...\n\tox = x.offset;\n\toy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache offset increments for the innermost loop...\n\tdx0 = sx[0];\n\tdy0 = sy[0];\n\n\t// Cache accessors:\n\tget = x.accessors[0];\n\tset = y.accessors[1];\n\n\t// Iterate over blocks...\n\tfor ( j9 = sh[9]; j9 > 0; ) {\n\t\tif ( j9 < bsize ) {\n\t\t\tS9 = j9;\n\t\t\tj9 = 0;\n\t\t} else {\n\t\t\tS9 = bsize;\n\t\t\tj9 -= bsize;\n\t\t}\n\t\tox9 = ox + ( j9*sx[9] );\n\t\toy9 = oy + ( j9*sy[9] );\n\t\tfor ( j8 = sh[8]; j8 > 0; ) {\n\t\t\tif ( j8 < bsize ) {\n\t\t\t\tS8 = j8;\n\t\t\t\tj8 = 0;\n\t\t\t} else {\n\t\t\t\tS8 = bsize;\n\t\t\t\tj8 -= bsize;\n\t\t\t}\n\t\t\tdx9 = sx[9] - ( S8*sx[8] );\n\t\t\tdy9 = sy[9] - ( S8*sy[8] );\n\t\t\tox8 = ox9 + ( j8*sx[8] );\n\t\t\toy8 = oy9 + ( j8*sy[8] );\n\t\t\tfor ( j7 = sh[7]; j7 > 0; ) {\n\t\t\t\tif ( j7 < bsize ) {\n\t\t\t\t\tS7 = j7;\n\t\t\t\t\tj7 = 0;\n\t\t\t\t} else {\n\t\t\t\t\tS7 = bsize;\n\t\t\t\t\tj7 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx8 = sx[8] - ( S7*sx[7] );\n\t\t\t\tdy8 = sy[8] - ( S7*sy[7] );\n\t\t\t\tox7 = ox8 + ( j7*sx[7] );\n\t\t\t\toy7 = oy8 + ( j7*sy[7] );\n\t\t\t\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\t\t\t\tif ( j6 < bsize ) {\n\t\t\t\t\t\tS6 = j6;\n\t\t\t\t\t\tj6 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tS6 = bsize;\n\t\t\t\t\t\tj6 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx7 = sx[7] - ( S6*sx[6] );\n\t\t\t\t\tdy7 = sy[7] - ( S6*sy[6] );\n\t\t\t\t\tox6 = ox7 + ( j6*sx[6] );\n\t\t\t\t\toy6 = oy7 + ( j6*sy[6] );\n\t\t\t\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\t\t\t\tif ( j5 < bsize ) {\n\t\t\t\t\t\t\tS5 = j5;\n\t\t\t\t\t\t\tj5 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tS5 = bsize;\n\t\t\t\t\t\t\tj5 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdx6 = sx[6] - ( S5*sx[5] );\n\t\t\t\t\t\tdy6 = sy[6] - ( S5*sy[5] );\n\t\t\t\t\t\tox5 = ox6 + ( j5*sx[5] );\n\t\t\t\t\t\toy5 = oy6 + ( j5*sy[5] );\n\t\t\t\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\t\t\t\tS4 = j4;\n\t\t\t\t\t\t\t\tj4 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tS4 = bsize;\n\t\t\t\t\t\t\t\tj4 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdx5 = sx[5] - ( S4*sx[4] );\n\t\t\t\t\t\t\tdy5 = sy[5] - ( S4*sy[4] );\n\t\t\t\t\t\t\tox4 = ox5 + ( j4*sx[4] );\n\t\t\t\t\t\t\toy4 = oy5 + ( j4*sy[4] );\n\t\t\t\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\t\t\t\tS3 = j3;\n\t\t\t\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tS3 = bsize;\n\t\t\t\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdx4 = sx[4] - ( S3*sx[3] );\n\t\t\t\t\t\t\t\tdy4 = sy[4] - ( S3*sy[3] );\n\t\t\t\t\t\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\t\t\t\t\t\toy3 = oy4 + ( j3*sy[3] );\n\t\t\t\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\t\t\t\tS2 = j2;\n\t\t\t\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tS2 = bsize;\n\t\t\t\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tdx3 = sx[3] - ( S2*sx[2] );\n\t\t\t\t\t\t\t\t\tdy3 = sy[3] - ( S2*sy[2] );\n\t\t\t\t\t\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\t\t\t\t\t\toy2 = oy3 + ( j2*sy[2] );\n\t\t\t\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\t\t\t\tS1 = j1;\n\t\t\t\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tS1 = bsize;\n\t\t\t\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tdx2 = sx[2] - ( S1*sx[1] );\n\t\t\t\t\t\t\t\t\t\tdy2 = sy[2] - ( S1*sy[1] );\n\t\t\t\t\t\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\t\t\t\t\t\toy1 = oy2 + ( j1*sy[1] );\n\t\t\t\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\t\t\t\tS0 = j0;\n\t\t\t\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tS0 = bsize;\n\t\t\t\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t// Compute index offsets for the first input and output ndarray elements in the current block...\n\t\t\t\t\t\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\t\t\t\t\t\t\t\t\t\t\tiy = oy1 + ( j0*sy[0] );\n\n\t\t\t\t\t\t\t\t\t\t\t// Compute loop offset increments...\n\t\t\t\t\t\t\t\t\t\t\tdx1 = sx[1] - ( S0*sx[0] );\n\t\t\t\t\t\t\t\t\t\t\tdy1 = sy[1] - ( S0*sy[0] );\n\n\t\t\t\t\t\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\t\t\t\t\t\tfor ( i9 = 0; i9 < S9; i9++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i8 = 0; i8 < S8; i8++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i7 = 0; i7 < S7; i7++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tset( ybuf, iy, fcn.call( thisArg, get( xbuf, ix ), take( [ i9, i8, i7, i6, i5, i4, i3, i2, i1, i0 ], idx ), x.ref ) );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy2;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy3;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy4;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx6;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy6;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx7;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy7;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx8;\n\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy8;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tix += dx9;\n\t\t\t\t\t\t\t\t\t\t\t\tiy += dy9;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedmap10d;\n"],"names":["MODE","MAP","x","y","fcn","thisArg","data","offset","call","ref","xbuf","ybuf","dx0","dy0","S0","ix","iy","i0","shape","strides","dx1","dy1","idx","sh","S1","sx","sy","i1","zeroTo","length","order","reverse","take","dx2","dy2","S2","i2","dx3","dy3","S3","i3","dx4","dy4","S4","i4","dx5","dy5","S5","i5","dx6","dy6","S6","i6","dx7","dy7","S7","i7","dx8","dy8","S8","i8","dx9","dy9","S9","i9","ACCESSOR_MAP","accessors","get","set","BLOCKED_MAP","bsize","ox1","oy1","s0","s1","ox","oy","j0","j1","o","loopOrder","blockSize","dtype","ox2","oy2","s2","j2","ox3","oy3","j3","ox4","oy4","j4","ox5","oy5","j5","ox6","oy6","j6","ox7","oy7","j7","ox8","oy8","j8","ox9","oy9","j9","BLOCKED_ACCESSOR_MAP","MAX_DIMS","map","arrays","ndims","xmmv","ymmv","shx","shy","iox","ioy","len","ns","i","d","ndarray2object","Error","accessorProtocol","iterationOrder","minmaxViewBufferIndex","ordx","ordy","numel","vind2bind","ind2sub","accessormapnd","mapnd"],"mappings":"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"}